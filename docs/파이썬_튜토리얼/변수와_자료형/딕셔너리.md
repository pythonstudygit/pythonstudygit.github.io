---
title: 딕셔너리
parent: 변수와 자료형
nav_order: 7
---

# 딕셔너리

앞서 본 리스트, 튜플은 정수 인덱스로 특정한 항목에 접근할 수 있었다.
딕셔너리의 경우 키와 값의 쌍으로 이루어진 자료형이다. 키를 통해 값에 접근할 수 있으며, 키는 문자열, 숫자, 튜플 등 불변 자료형을 사용할 수 있다.

## 딕셔너리 생성하기

딕셔너리는 중괄호(`{}`)를 사용하여 생성하며, 각 항목은 `키:값` 형태로 표현된다.

```python
colors = {
    'RED': '0xFF0000',
    'GREEN': '0x00FF00',
    'BLUE': '0x0000FF'
}
print(type(colors))
print(colors)
```
```
>>>
<class 'dict'>
{'RED': '0xFF0000', 'GREEN': '0x00FF00', 'BLUE': '0x0000FF'}
```

다음과 같이 dict 클래스로도 생성할 수 있다.

```python
colors = dict(RED='0xFF0000', GREEN='0x00FF00', BLUE='0x0000FF')
print(type(colors))
print(colors)
```
```
>>>
<class 'dict'>
{'RED': '0xFF0000', 'GREEN': '0x00FF00', 'BLUE': '0x0000FF'}
```

키는 중복으로 사용할 경우 마지막에 할당한 값만 남는다. (중복 제거)

```python
config = {
    'theme': 'dark',
    'font_size': 14,
    'language': 'ko-kr',
    'notifications': True,
    'theme': 'light'
}
print(config)
```
```
>>>
{'theme': 'light', 'font_size': 14, 'language': 'ko-kr', 'notifications': True}
```

해시 불가능한<sub>unhashable</sub> 자료형인 리스트나 딕셔너리 등의 가변<sub>mutable</sub> 객체는 딕셔너리의 키로 사용할 수 없다.

```python
dict1 = {}
dict2 = {dict1: 0}
```
```
>>>
  ..., line 2, in <module>
    dict2 = {dict1: 0}
            ^^^^^^^^^^
TypeError: unhashable type: 'dict'
```

> { :Note }  
> 해시 가능<sub>hashable</sub>한 객체는 객체 생애 동안 변하지 않는 해시 값을 가지고 있으며, 다른 객체와 비교가 가능하다는 것을 의미한다.
> 객체의 해시 가능함은 구체적으로 아래의 조건을 따른다.  
> 객체 생애 동안 변하지 않는 해시 값을 가지고 있으며 => `__hash__` 메서드 필요
> 다른 객체와 비교 가능함 => `__eq__` 메서드 필요


## 매핑된 값 가져오기

딕셔너리 객체 대괄호(`[]`)안에 키를 넣어 해당 키에 매핑된 값에 가져올 수 있다.

```python
prices = {
    '스페셜': 100_000,
    '생선구이': 20_000,
    '장어구이': 12_000,
    '모듬회': 50_000,
    '회덮밥': 15_000
}
print('생선구이 가격:', prices['생선구이'], '원')
```
```
>>>
생선구이 가격: 20000 원
```

접근하고자 하는 키가 딕셔너리에 없으면 `KeyError`가  발생한다.

```python
prices = {
    '스페셜': 100_000,
    '생선구이': 20_000,
    '장어구이': 12_000,
    '모듬회': 50_000,
    '회덮밥': 15_000
}

prices['닭갈비']
```
```
>>>
Traceback (most recent call last):
  ..., line 9, in <module>
    prices['닭갈비']
    ~~~~~~^^^^^^^^^^
KeyError: '닭갈비'
```

## 딕셔너리 키-값 쌍 추가 및 값 수정하기

딕셔너리에 새로운 키-값 쌍을 추가하거나 기존 키의 값을 수정할 때는 대괄호(`[]`)를 사용한다.
다음은 과일 시세 정보가 있는 딕셔너리에 새로운 가격 변경, 새로운 과일 추가하는 예제이다.

```python
fruits_prices = {
    '사과': 10_900,
    '바나나': 23_900,
}
print(fruits_prices)

fruits_prices['사과'] = 13_400 # 딕셔너리 값 수정
print(fruits_prices)

fruits_prices['딸기'] = 9_900 # 키-값 쌍 추가
print(fruits_prices)
```
```
>>>
{'사과': 10900, '바나나': 23900}
{'사과': 13400, '바나나': 23900}
{'사과': 13400, '바나나': 23900, '딸기': 9900}
```

## 딕셔너리 관련 메소드

아래 소개하는 메서드들은 다음 딕셔너리를 활용한다.

```python
mydict = {
    'a': 1,
    'b': 2,
    'c': 3
}
```

### `keys` - 딕셔너리에 등록된 모든 키 반환

```python
dict_keys = mydict.keys()
print(dict_keys)
print(list(dict_keys))
```
```
>>>
dict_keys(['a', 'b', 'c'])
['a', 'b', 'c']
```

### `values` - 딕셔너리에 등록된 모든 값 반환

```python
dict_values = mydict.values()
print(dict_values)
print(list(dict_values))
```
```
>>>
dict_values([1, 2, 3])
[1, 2, 3]
```

### `items` - 딕셔너리에 등록된 모든 키/값 반환

```python
dict_items = mydict.items()
print(dict_items)
print(list(dict_items))
```
```
>>>
dict_items([('a', 1), ('b', 2), ('c', 3)])
[('a', 1), ('b', 2), ('c', 3)]
```

### `get`

`get` 메서드는 딕셔너리에서 키를 검색하여 해당 값을 반환한다.
키가 존재하지 않으면 메서드의 두 번째 인자로 지정된 기본값을 반환한다.
대괄호(`[]`)로 점근할 때와 달리 KeyError 가 발생하지 않는다는 점이 특징이다.

```python
print("get 메서드 (키 존재):", mydict.get('b'))
print("get 메서드 (키 미존재):", mydict.get('d'))
print(mydict)
```
```
>>>
get 메서드 (키 존재): 2
get 메서드 (키 미존재): None
{'a': 1, 'b': 2, 'c': 3}
```

### `setdefault`

`setdefault` 메서드는 딕셔너리에서 키를 검색하고 키가 존재할 경우 해당 키의 현재 값을 반환한다.
키가 존재하지 않을 경우 딕셔너리에 새 키-값 쌍을 추가하고 그 값을 반환한다.

```python
print(mydict.setdefault('c'))
print(mydict.setdefault('d'))
print(mydict)
```
```
>>>
3
None
{'a': 1, 'b': 2, 'c': 3, 'd': None}
```

## 딕셔너리 병합

서로 다른 딕셔너리 간 병합이 가능하다.

```python
dict1 = {
    'a': 100,
    'b': 100,
    'c': 100,
    'd': 100,
}

dict2 = {
    'f': 200,
    'e': 200,
    'd': 200,
    'c': 200,
}

dict3 = dict1 | dict2
dict4 = dict2 | dict1

print("dict1:", dict1)
print("dict2:", dict2)
print("dict1 | dict2:", dict3)
print("dict2 | dict1:", dict4)
```
```
>>>
dict1: {'a': 100, 'b': 100, 'c': 100, 'd': 100}
dict2: {'f': 200, 'e': 200, 'd': 200, 'c': 200}
dict1 | dict2: {'a': 100, 'b': 100, 'c': 200, 'd': 200, 'f': 200, 'e': 200}
dict2 | dict1: {'f': 200, 'e': 200, 'd': 100, 'c': 100, 'a': 100, 'b': 100}
```

이 예제에서 알 수 있는 점은 다음과 같다.

* 두 딕셔너리의 모든 키가 결과에 포함된다. 단 중복된 키는 하나만 사용된다. 
* `|` 연산자의 왼쪽 딕셔너리가 먼저 오고, 오른쪽 딕셔너리의 키가 그 뒤에 추가된다.
* 키가 중복되는 경우에는 `|` 연산자 오른쪽 딕셔너리의 값이 사용된다.

`|=` 복합연산자도 지원된다. 새로운 딕셔너리를 생성할 필요가 없을 때 사용하면 된다.  
다음 예제는 앞서 본 `dict1`, `dict2` 를 재활용한다.

```python
dict1 |= dict2
print(dict1)
print(dict2)
```

## 딕셔너리 중첩

딕셔너리는 키에 매핑되는 값으로 딕셔너리를 사용할 수 있다. 즉 중첩이 가능하다.

```python
game_characters = {
    '마법사': {
        '기본 능력치': {'체력': 400, '마나': 800, '공격력': 50, '방어력': 30},
        '스킬': {
            '파이어볼': {'데미지': 150, '마나 소모': 50, '쿨타임': 3},
            '블리자드': {'데미지': 200, '마나 소모': 80, '쿨타임': 6},
            '텔레포트': {'효과': '순간이동', '마나 소모': 30, '쿨타임': 4}
        },
        '장비': {'무기': '마법 지팡이', '방어구': '마법사 로브'}
    },
    '전사': {
        '기본 능력치': {'체력': 800, '마나': 200, '공격력': 120, '방어력': 80},
        '스킬': {
            '강타': {'데미지': 180, '마나 소모': 20, '쿨타임': 2},
            '방패 막기': {'방어력 증가': 50, '마나 소모': 15, '지속시간': 3},
            '돌진': {'데미지': 100, '이동 효과': '전방 5미터', '마나 소모': 25}
        },
        '장비': {'무기': '대검', '방어구': '판금 갑옷'}
    }
}

magician_base_ability = game_characters['마법사']['기본 능력치']

print(f"마법사 체력/마나: {magician_base_ability['체력']}/{magician_base_ability['마나']}")
print(f"전사 돌진 스킬 데미지: {game_characters['전사']['스킬']['돌진']}")
```
```
마법사 체력/마나: 400/800
전사 돌진 스킬 데미지: {'데미지': 100, '이동 효과': '전방 5미터', '마나 소모': 25}
```

## 연습문제

### 연습문제1

다음은 식품 가격에 대한 딕셔너리입니다.

```python
food_prices = {
    "우유": 1500,
    "식빵": 5000,
    "커피": 2800
}
```

1. 식품명을 입력받습니다.
2. 식품이 딕셔너리에 있으면 "... 원 입니다." 를 출력합니다.
3. 식품이 딕셔너리에 존재하지 않으면 "해당 식품은 준비중입니다." 를 출력합니다.

### 연습문제2

다음과 같이 역사 인물의 생몰연도, 업적을 포함하는 딕셔너리가 있습니다.

```python
historical_figures = {
  "이순신": {
    "생몰연도": "1545~1598",    
    "업적": ["옥포해전 승리", "명량해전 승리"]
  },
  "세종대왕": {
    "생몰연도": "1397~1350",
    "업적": ["훈민정음 창제", "집현전 설치"]
  }
}
```

1. 이순신 업적에 '노량해전 승리' 를 추가하세요.
2. 세종대왕 생몰연도를 1397~1450 으로 수정하세요.
3. 태조 왕건 키-값 쌍도 형식에 맞추어 추가해보세요. 태조 왕건의 정보는 다음과 같습니다.
  * 생몰연도: 877~943 (문자열)
  * 업적: 후삼국 통일 (리스트[문자열])
4. 딕셔너리에서 각 인물의 사망연도를 추출합니다.