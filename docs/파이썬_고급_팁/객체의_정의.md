---
title: 객체의 정의
parent: 파이썬 고급 팁
nav_order: 3 
---

# 객체의 정의

파이썬에서 객체는 데이터를 추상화한 개념으로, 프로그램 내의 모든 데이터는 객체로 표현되거나 객체 간의 관계로 표현된다.

모든 객체는 **식별자<sub>identity</sub>**, **타입<sub>type</sub>**, **값<sub>value</sub>** 을 갖는다.

* **식별자:** 객체의 식별자는 한 번 생성되면 절대 바뀌지 않는다.
  두 객체가 동일한지는 `is` 연산자를 사용하고, `id()` 함수는 이 식별자를 나타내는 정수를 나타낸다.
  CPython 의 경우 `id(x)` 함수는 객체 x 가 저장된 메모리 주소를 정수로 반환한다.

* **타입:** 객체의 타입은 **객체가 지원하는 연산을 결정**하고, 그 타입의 **객체가 가질 수 있는 값을 정의**한다.
  타입을 확인할 때는 `type()` 함수를 쓰며, `type()` 함수가 반환하는 값(객체의 타입)자체도 객체이다.
  
  ```python
  print(type(3))
  print(type(type(3)))
  ```
  ```
  >>>
  <class 'int'>
  <class 'type'>
  ```
  식별자와 마찬가지로 객체의 타입도 바뀌지 않는다.

## 객체의 값 변경

객체의 값은 변경 가능성<sub>mutability</sub>에 따라 달라질 수 있다.

* **가변적<sub>mutable</sub>:** 생성 후 값이 변할 수 있는 객체 (list, dictionary, ...)
* **불변적<sub>immutable</sub>:** 생성 후 값이 변하지 않는 객체 (int, str, tuple, ...)

> {: .note }  
> 불변 컨테이너 객체 안에 가변 객체를 참조로 가지고 있는 경우, 내부에 있는 가변 객체의 값이 변하면 겉으로 보이는 컨테이너 객체의 값도 변할 수 있다.
> 그러나 이 경우에도 컨테이너 자체는 여전히 불변으로 취급된다.
> 즉, 불변성은 "절대로 값이 바뀌지 않는다" 와 정확히 같은 의미는 아니다.
> 
> 예를 들면, 튜플 안에 항목으로 리스트가 있는 경우 해당 리스트는 변경 가능하다.
> ```python
> test_tuple = (1, 2, [3, 4])
> test_tuple[2].append(5)
> print(test_tuple)
> ```
> ```
> >>>
> (1, 2, [3, 4, 5])
> ```

## 객체의 파괴<sub>destroy</sub>

객체는 명시적으로 파괴되지 않는다.
하지만 객체가 더 이상 접근할 수 없게 되면, 가비지 컬렉션<sub>garbage collection</sub>의 대상이 될 수 있다.
구현 방식에 따라 가비지 컬렉션은 지연되거나 아예 수행되지 않을 수 있으며, 어떻게 구현할지는 구현의 품질에 따라 달라질 수 있다.
다만, 접근 가능한 객체가 가비지 컬렉션에 수집되는 일은 없어야 한다.

CPython 은 참조 카운트<sub>reference counting</sub>을 사용하여, 객체가 접근 불가능하게 되자마자 대부분 즉시 수집한다.
다만, 순환 참조<sub>cyclic reference</sub>를 가진 객체는 선택적으로 늦게 감치하며 반드시 즉시 수집되는 것은 아니다.

> {: .Warning }  
> 객체가 접근 불가능해지자마자 즉시 제거<sub>finalize</sub>된다는 점에 의존하면 안된다.
> 예를 들어 파일은 반드시 명시적으로 닫아주는 것이 좋다.

일부 객체는 열린 파일<sub>open file</sub>이나 윈도우<sub>window</sub>와 같은 외부 자원에 대한 참조를 가지고 있다.
원칙적으로 이러한 자원은 객체가 가비지 컬렉션될 때 해제되지만, 가비지 컬렉션이 반드시 발생한다는 보장이 없으므로 보통 이런 객체들은 외부 자원을 명시적으로 해제하는 메서드(`close()` 등)을 제공한다.
따라서 프로그래밍 시 외부 자원을 닫는 것을 강력히 권장하며, 이를 쉽게 하기 위한 방법으로 `try...finally` 문 또는 `with` 문이 있다.

## 컨테이너

객체 중에 다른 객체에 대한 참조를 가진 것이 있으며, 이를 컨테이너<sub>container</sub> 라고 한다.
튜플, 리스트, 딕셔너리 등이 대표적인 예이다.
참조는 컨테이너 객체의 값의 일부이다. 보통 컨테이너의 값을 이야기할 때는 내부 객체들의 식별자가 아닌 값을 의미한다.
하지만 컨테이너의 가변성<sub>mutability</sub>을 이야기할 때는 내부에 있는 객체들의 식별자만을 고려한다.
따라서 튜플처럼 불편 컨테이너라도 내부에 있는 가변 객체가 변하면 값이 변할 수 있다.

객체의 타입은 객체의 거의 모든 행동을 결정하며, 심지어 식별자의 중요성도 타입에 따라 달라진다.
불변 타입의 경우, 새로운 값을 만드는 연산을 수행할 때 동일한 값과 타입을 가진 기존 객체의 참조를 재사용할 수도 있지만, 가변 객체에서는 이것이 허용되지 않는다.

예시로, `a = 1; b = 1`  을 할 때, `a` 와 `b` 는 같은 객체일 수도 있고 아닐 수도 있다.
이는 구현체의 결정에 따라 달라진다.
반면, 가변 객체는 반드시 매번 새로운 객체를 생성한다.
즉, `c = []; d = []` 를 하면, `c` 와 `d` 는 항상 서로 다른 새 리스트 객체인 것이다. (단, `e = f = []`)는 같은 리스트 객체 하나를 둘 다 참조하는 것이다.)

## 추가 자료

* [The Python Language Reference - Data Model](https://docs.python.org/3.12/reference/datamodel.html#objects-values-and-types)  
* [gc - Garbage Collector interface](https://docs.python.org/3.12/library/gc.html)