{"0": {
    "doc": "Django",
    "title": "Django",
    "content": " ",
    "url": "/docs/Django/Django.html",
    
    "relUrl": "/docs/Django/Django.html"
  },"1": {
    "doc": "Gang of Four",
    "title": "Gang of Four",
    "content": "이 파트에서는 Gang of Four 의 고전 디자인 패턴을 탐구한다. 이 패턴들은 일상적인 문제 해결에 사용되며, 파이썬 개발자로서 이를 어떻게 적용할 수 있는지를 다룬다. 다음은 Gang of Four 의 책에서 발췌한 디자인 패턴에 관한 인용문이다. 디자인 패턴은 객체 지향 시스템에서 반복적으로 발생하는 디자인 문제에 대응하기 위해 일반적인 설계를 체계적으로 명명, 동기 부여, 설명하는 방법이다. 이 패턴은 문제, 해결책, 해결책을 적용할 시기 및 그 결과를 설명하며, 구현에 대한 힌트와 예제를 제공한다. 즉, 문제를 해결하기 위한 객체와 클래스들의 일반적인 구성 방식을 제시하고, 이를 특정 상황에 맞게 맞춤 구현한다. 객체 지향 프로그래밍에서 디자인 패턴은 해결하려는 문제의 유형이나 구축하려는 솔루션에 따라 여러 범주로 나뉜다. Gang of Four 의 책에서는 23 개의 디자인 패턴을 세 가지 범주(생성, 구조, 행동)으로 구분하여 소개한다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/Gang_of_Four.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/Gang_of_Four.html"
  },"2": {
    "doc": "Hello World 웹사이트",
    "title": "Hello World 웹사이트",
    "content": "이 장에서는 웹사이트와 웹 프레임워크가 어떻게 작동하는지 검토하고, Django 의 아키텍처를 살펴본 후 “Hello World” 를 표시하는 간단한 Django 웹사이트를 구축해 볼 것이다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html"
  },"3": {
    "doc": "Hello World 웹사이트",
    "title": "인터넷 작동 방식",
    "content": "https://learndjango.com 웹사이트에 접속할 때 발생하는 과정을 여섯 단계로 간략하게 정리하면 다음과 같다. | 브라우저에 도메인 이름을 입력한다. | 브라우저는 DNS 를 통해 도메인 이름에 해당하는 IP 주소를 조회한다. | 브라우저는 해당 IP 주소의 웹 서버와 네트워크 연결을 설정한다. | 브라우저는 원하는 리소스에 대한 HTTP 요청을 보낸다. | 웹사이트는 요청을 처리한 후 HTTP 응답을 반환한다. | 브라우저는 응답 내용을 기반으로 웹페이지를 랜더링한다. | . ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%EC%9D%B8%ED%84%B0%EB%84%B7-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#인터넷-작동-방식"
  },"4": {
    "doc": "Hello World 웹사이트",
    "title": "웹 프레임워크 작동 방식",
    "content": "웹사이틑 기본적으로 정적static과 동적dynamic 두 가지 유형으로 나뉜다. 정적 웹사이트는 개별 HTML 문서로 구성되며, 예를 들어 10페이지로 구성된 웹사이트라면 10개의 HTML 문서가 필요하다. 이 방식은 매우 작은 규모의 사이트에만 적합하다. 반면에 대부분의 웹사이트는 데이터메이스, HTML 템플릿, 그리고 브라우저로 전송되기 전에 파일을 생성할 수 있는 애플리케이션 서버로 구성된 동적 웹사이트다. 동적 웹사이트에서는 상대적으로 적은 코드로 수백, 때로는 수천 개의 웹 페이지를 생성할 수 있다. Django 와 같은 웹 프레임워크는 이러한 동적 웹사이트를 위해 설계되었다. 웹 프레임워크인 Django 의 핵심 역할은 다음 세 가지이다. | 웹페이지를 랜더링하기 위해 URL 을 뷰 로직에 매핑한다. | 데이터베이스와 상호작용하기 위한 추상화 계층을 제공한다. | 템플릿 시스템을 통해 HTML 과 유사한 코드를 출력한다. | . ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%EC%9B%B9-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#웹-프레임워크-작동-방식"
  },"5": {
    "doc": "Hello World 웹사이트",
    "title": "Django 아키텍처",
    "content": "Django 에서 고려해야 할 네 가지 주요 구성 요소는 URL, View, Model, Template 이다. 시각적으로 Django 의 요청/응답 주기는 위 다이어그램과 같으며, 실선은 필수 상호 작용을, 점선은 선택적 상호작용을 나타낸다. | 웹 브라우저에서 HTTP 요청 가 들어오면, 가장 먼저 Django 의 URL Displaycher(urls.py) 가 동작하여 설정된 URL 패턴을 검색한 뒤 처음으로 일치하는 **View(view.py)** 에 요청을 전달한다. | 해당 View 는 요청된 데이터와 스타일을 조합해 HTTP 응답을 생성한 뒤 웹 브라우저로 반환한다. 사실 이 두가지만으로도 Django 웹사이트를 구성할 수 있다. (URL Dispatcher 와 View 만 사용) | . 그러나 실제로는 Model 과 Template 이 추가되는 경우가 더 흔하다. | 데이터베이스를 사용하는 웹사이트에서는 View 가 Model(models.py) 과 상호작용한다. Model 은 데이터베이스 테이블과 동작 방식을 정의하며, 데이터베이스 쿼리를 지원한다. | 이 데이터를 다시 View 로 전달하면, 보통 Template(HTML, XML, JSON 등 텍스트 기반 파일 형식) 을 통해 화면에 랜더링할 수 있는 형태로 변환한다. | 최종적으로 View 가 필요한 정보를 모두 확보하면, 웹 브라우저에 HTTP 응답을 반환한다. | . ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#django-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#django-아키텍처"
  },"6": {
    "doc": "Hello World 웹사이트",
    "title": "Model-View-Controller vs Model-View-Template",
    "content": "MVC 패턴(Model-View-Controller) 은 애플리케이션의 데이터와 로직, 그리고 표시 영역을 분리해 개발자가 보다 쉽게 구조를 이해할 수 있도록 도와준다. 전통적인 MVC 패턴은 세 가지 주요 구성 요소가 있다. | **Model:** 데이터와 핵심 비즈니스 로직을 관리 | **View:** 모델의 데이터를 특정 형식으로 랜더링 | **Controller:** 사용자 입력을 받아 애플리케이션에 맞는 로직을 수행 | . Django 의 접근 방식은 종종 MVT(Model-View-Template) 라고 불리지만, 실제로는 URL 설정을 포함한 4가지 요소, 즉 **MVTU(Model-View-Template-URL)** 패턴에 더 가깝다. | Model: 데이터와 핵심 비즈니스 로직을 관리 | View: 사용자에게 어떤 데이터를 보낼지 결정하되, 그 표현 방식은 정의하지 않음 | Template: HTML(필요에 따라 CSS, JavaScript, 정적 자산static assets 포함) 을 사용해 데이터를 표시 | URL Configuration: 정규 표현식을 사용해 URL 을 뷰에 연결 | . 전통적인 MVC 패턴과 장고의 MVT 패턴를 비교하면 다음과 같이 이야기할 수 있다. | MVC 에서의 View 는 Django 의 Template 과 유사하다. | MVC 에서의 Controller 는 Django 의 View 와 URL Dispatcher 로 나누어져 있다. | . ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#model-view-controller-vs-model-view-template",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#model-view-controller-vs-model-view-template"
  },"7": {
    "doc": "Hello World 웹사이트",
    "title": "Django 의 기본 파일 구성",
    "content": "이번 장에서는 가능한 한 간단하게 “Hello, World” 웹 사이트를 만들어 본다. 일반적으로 Django 웹사이트에는 URL Dispatcher, View, Model, Template 모두 사용되지만, 사실 URL Dispatcher 와 View 만으로도 동작이 가능하다. 이번 예시에서는 URL Dispatcher 와 View 만 사용한다. 장고 시작하기 에서 만든 가상 환경에서 실습한다. &gt; tree /f /a | manage.py | \\---django_project asgi.py settings.py urls.py wsgi.py __init__.py . | init.py: 해당 폴더의 파일들이 파이썬 패키지의 일부임을 알리는 파일이다. 이 파일이 없으면 Django 에서 종종 필요한 디렉토리 간 파일 임포트가 불가능하다. | asgi.py: 선택적으로 사용할 수 있는 ASGI(Asynchronous Server Gateway Interface) 애플리케이션을 설정한다. | settings.py: Django 프로젝트 전반의 설정을 담당한다. | urls.py: 브라우저나 URL 요청에 대해 어떤 페이지를 구성할지 Django 에 알려준다. | wsgi.py: Django 의 기본 설정인 WSGI(Web Server Gateway Interface) 애플리케이션을 설정한다. | . manage.py 파일은 django_project 디렉토리의 일부가 아니며, 로컬 웹 서버 실행이나 새 앱 생성 등 다양한 Django 관리 명령어를 실행할 때 사용된다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#django-%EC%9D%98-%EA%B8%B0%EB%B3%B8-%ED%8C%8C%EC%9D%BC-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#django-의-기본-파일-구성"
  },"8": {
    "doc": "Hello World 웹사이트",
    "title": "마이그레이션",
    "content": "&gt; python manage.py runserver Watching for file changes with StatReloader Performing system checks... System check identified no issues (0 silenced). You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions. Run 'python manage.py migrate' to apply them. March 02, 2025 - 01:11:25 Django version 5.0.12, using settings 'django_project.settings' Starting development server at http://127.0.0.1:8000/ Quit the server with CTRL-BREAK. Django 서버를 시작하면 You have 18 unapplied migration(s) 문구에 보이는데, 이번에 그것이 무엇인지 살펴보자. 마이그레이션은 Django 가 데이터베이스 변경 사항을 추적하기 위해 자동으로 생성하는 특별한 스크립트이다. 시간이 지남에 따라 프로젝트가 커지면, 데이터베이스와 모든 테이블의 구조를 정의하는 Django 데이터베이스 모델에 여러 변경이 생기기 마련이다. Django 의 마이그레이션 프레임워크를 사용하면, 이러한 변경 사항을 시간순으로 추적하여 특정 마이그레이션 파일에 정의된 구성과 동일하도록 데이터베이스를 수정할 수 있다. startproject 명령어로 새 프로젝트를 시작하면, Django 에는 admin, auth, contenttypes, sessions 등의 여러 내장 앱이 포함된다. 이 앱들은 데이터베이스에 변경 사항을 적용한다. 로컬 데이터베이스에 해당 변경 사항을 반영하기 위해서는 migrate 관리 명령어를 사용하면 된다. 로컬 서버를 중지하고 migrate 명령을 사용해 보자. &gt; python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, sessions Running migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying admin.0003_logentry_add_action_flag_choices... OK ... Applying auth.0012_alter_user_first_name_max_length... OK Applying sessions.0001_initial... OK . migrate 명령어는 사용 가능한 모든 마이그레이션을 적용하며, admin, auth, contenttypes, sessions 등의 앱에 관한 마이그레이션을 나열한다. 예를 들어, Applying contenttypes.0001_initial... OK 는 contenttypes 앱의 0001_initial 마이그레이션 스크립트가 성공적으로 실행되었음을 의미한다. 이제 로컬 서버를 다시 실행해보면 더 이상 경고가 나타나지 않는다. &gt; python manage.py runserver Watching for file changes with StatReloader Performing system checks... System check identified no issues (0 silenced). March 02, 2025 - 01:20:47 Django version 5.0.12, using settings 'django_project.settings' Starting development server at http://127.0.0.1:8000/ Quit the server with CTRL-BREAK. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#마이그레이션"
  },"9": {
    "doc": "Hello World 웹사이트",
    "title": "앱App 생성하기",
    "content": "하나의 Django 프로젝트는 여러 개의 앱을 포함할 수 있다. 이는 코드를 깔끔하고 읽기 쉽게 유지하기 위한 조직적 기법이다. 각 앱은 특정 기능을 담당하도록 분리되어야 한다. django_project/settings.py 파일을 살펴보면, Django 가 기본으로 제공하는 여섯 개의 내장 앱이 이미 설정되어 있다. 이들은 모두 django.contrib 디렉토리에 위치하며 admin, auth, contenttypes, sessions, messages, staticfiles 기능을 제어한다. django_project/settings.py . INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', ] . 사실 원하는 경우 모든 코드를 단일 파일에 작성해도 문제는 없지만, 앱으로 기능을 분리해두면 Django 프로젝트의 구조를 더욱 명확히 이해하고 유지보수하기 쉬워진다. 예를 들어, 전자상거래(e-commerce) 웹사이트라면, 사용자 인증을 위한 앱, 결제 기능을 위한 앱, 상품 상세 정보를 제공하는 앱 등을 각각 따로 두는 식이다. 앱으로 기능을 분리하는 시점은 주관적이지만, 한 앱에 너무 많은 기능이 몰려 있다고 느껴지면 나누는 것이 좋다. 새로운 앱을 만들기 위해 우선 현재 실행 중인 서버를 종료한다. 그리고 startapp 명령어 뒤에 만들고자 하는 앱 이름을 입력한다. 예시에서는 pages 라는 이름을 사용한다. Django 에서는 관례상 앱 이름을 복수형(예: pages, payments 등)으로 쓰는 것이 좋다. 단, blog 처럼 복수형이 어색한 경우는 예외이다. &gt; python manage.py startapp pages . 이 명령을 실행하면 django_project 디렉토리 안에 새로운 pages 디렉토리가 생성되고, 아래와 같은 파일들이 포함된다. \\---pages | admin.py | apps.py | models.py | tests.py | views.py | __init__.py | \\---migrations __init__.py . 각 파일은 다음과 같은 역할을 한다. | admin.py: Django 의 내장 Admin 앱 설정을 위한 파일 | apps.py: 해당 앱 자체에 대한 설정 파일 | models.py: 데이터베이스 모델을 정의하는 파일. Django 가 이를 자동으로 데이터베이스 테이블로 변환 | migrations/: models.py 파일 변경 사항을 추적해 데이터베이스와 동기화하기 위한 마이그레이션 스크립트를 저장 | test.py: 앱별 테스트 코드를 작성하는 파일 | views.py: 웹 앱의 요청/응답 로직을 처리하는 파일 | . 새로운 앱이 생성되었지만 Django 가 이를 인식하도록 django_project/settings.py 파일의 INSTALLED_APPS 목록에 앱 이름을 명시해줘야 한다. 에디터에서 django_project/settings.py 파일을 열고, 기존의 여섯 개 내장 앱 아래에 pages 를 추가하자. django_project/settings.py . INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'pages', # new ] . ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%EC%95%B1app-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#앱app-생성하기"
  },"10": {
    "doc": "Hello World 웹사이트",
    "title": "첫 번째 View 만들기",
    "content": "이번에는 “Hello, World!” 라는 텍스트를 출력하는 정적 페이지를 만들어본다. 이 페이지는 데이터페이스나 템플릿 파일을 사용하지 않으며, Django 의 View 와 URL 이 어떻게 동작하는지 간단하게 소개한다. View 는 웹 요청을 받아 웹 응답을 반환하는 파이썬 함수이다. 응답은 웹 페이지의 HTML 내용, 리다이렉트, 404 에러, 이미지 등 거의 모든 형태가 될 수 있다. 웹 페이지가 요청되면 Django 는 자동으로 요청에 대한 메타데이터를 담은 HttpRequest 객체를 생성한다. 이후 Django 는 적절한 View 를 로드하여 이 HttpRequest 객체를 첫 번째 매개변수로 전달한다. View 는 최종적으로 HttpResponse 객체를 반환하는 역할을 한다. pages 앱 안에 있는 views.py 파일의 초기 내용은 아래와 같다. pages/views.py . from django.shortcuts import render # Create your views here. render 를 다루는 것은 다음 장에서 하고, 지금은 pages/views.py 파일을 아래와 같이 업데이트 한다. pages/views.py . from django.http import HttpResponse def home_page_view(request): return HttpResponse(\"Hello, World!\") . | from django.http import HttpResponse: django.http 모듈에서 HttpResponse 클래스를 가져온다. | def home_page_view(request):: home_page_view 라는 함수를 정의한다. | 함수의 첫 번째 매개변수는 HttpRequest 객체로 관례상 request 라는 이름을 사용한다. (이름은 달라도 순서가 맞으면 작동함) | 이 view 는 “Hello, World!” 라는 텍스트가 담긴 HttpResponse 객체를 반환한다. | . 모든 view 는 이와 같이 작성된다. 먼저 view 의 이름을 정의하고, HttpRequest (여기서는 request) 객체를 받으며, 최종적으로 HttpResponse 객체를 반환한다. 추가 로직이나 매개변수를 넣을 수 있지만, 기본 패턴은 동일하다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%EC%B2%AB-%EB%B2%88%EC%A7%B8-view-%EB%A7%8C%EB%93%A4%EA%B8%B0",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#첫-번째-view-만들기"
  },"11": {
    "doc": "Hello World 웹사이트",
    "title": "URL Dispatcher",
    "content": "View 를 준비했으니 이제 관련 URL 을 구성할 차례이다. pages/urls.py 파일을 새로 생성하고 아래의 코드로 업데이트 하자. pages/urls.py . from django.urls import path from .views import home_page_view urlpatterns = [ path(\"\", home_page_view) ] . | from django.urls import path: Django 의 path 를 가져와 URL 패턴을 설정한다. | . 이 URL 패턴은 두 부분으로 이루어진다. | 경로(route): 여기서는 빈 문자열 \"\" 로 정의 | 뷰 참조(view): home_page_view | . 즉, 사용자가 빈 문자열로 표현되는 홈페이지를 요청하면, Django 는 home_page_view View 를 실행하게 된다. 다음 단계는 프로젝의 진입점인 django_project/urls.py 파일을 업데이트 하는 것이다. 이 파일은 각 앱에 속하지 않는 다른 URL 패턴들의 관문 역할을 한다. (이 아키텍처 패턴은 앞으로 복잡한 웹 애플리케이션을 만들면서 점점 더 중요해진다.) . Django 는 내장 관리자(admin)을 위한 경로를 자동으로 설정한다. 추가 URL 경로를 포함시키기 위해, django.urls 모듈에서 include 함수를 가져온 후, 다시 빈 문자열 \"\" 을 사용하여 pages 앱에 포함된 모든 URL 을 불러온다. 자세한 내부 작동 방식은 Django 공식 문서를 참고하자. 업데이트된 코드는 다음과 같다. from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path(\"\", include(\"pages.urls\")) ] . 이제 사용자가 빈 문자열로 표현되는 홈페이지를 방문하면 Django 는 pages 앱 내에서 일치하는 URL 경로를 찾는다. 서버가 정상 작동하는지 확인하기 위해 Django 서버를 시작하자. 웹브라우저에서 http://localhost:8000 또는 http://127.0.0.1:8000 접속했을 때 위 스크린샷과 같이 뜨면 정상적으로 동작한 것이다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#url-dispatcher",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/Hello_World_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#url-dispatcher"
  },"12": {
    "doc": "OpenAI",
    "title": "OpenAI",
    "content": " ",
    "url": "/docs/OpenAI/OpenAI.html",
    
    "relUrl": "/docs/OpenAI/OpenAI.html"
  },"13": {
    "doc": "Pandas",
    "title": "Pandas",
    "content": " ",
    "url": "/docs/Pandas/Pandas.html",
    
    "relUrl": "/docs/Pandas/Pandas.html"
  },"14": {
    "doc": "Pycharm 설치",
    "title": "Pycharm 설치",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/Pycharm_%EC%84%A4%EC%B9%98/Pycharm_%EC%84%A4%EC%B9%98.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/Pycharm_%EC%84%A4%EC%B9%98/Pycharm_%EC%84%A4%EC%B9%98.html"
  },"15": {
    "doc": "Pycharm 설치",
    "title": "Pycharm 다운로드",
    "content": ". | 아래 링크에서 PyCharm Community Edition 다운로드 https://www.jetbrains.com/pycharm/download/ | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/Pycharm_%EC%84%A4%EC%B9%98/Pycharm_%EC%84%A4%EC%B9%98.html#pycharm-%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/Pycharm_%EC%84%A4%EC%B9%98/Pycharm_%EC%84%A4%EC%B9%98.html#pycharm-다운로드"
  },"16": {
    "doc": "Pycharm 설치",
    "title": "Pycharm 설치",
    "content": ". ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/Pycharm_%EC%84%A4%EC%B9%98/Pycharm_%EC%84%A4%EC%B9%98.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/Pycharm_%EC%84%A4%EC%B9%98/Pycharm_%EC%84%A4%EC%B9%98.html"
  },"17": {
    "doc": "Pycharm 설치",
    "title": "Pycharm 실행",
    "content": ". ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/Pycharm_%EC%84%A4%EC%B9%98/Pycharm_%EC%84%A4%EC%B9%98.html#pycharm-%EC%8B%A4%ED%96%89",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/Pycharm_%EC%84%A4%EC%B9%98/Pycharm_%EC%84%A4%EC%B9%98.html#pycharm-실행"
  },"18": {
    "doc": "Python 설치",
    "title": "Python 설치",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/Python_%EC%84%A4%EC%B9%98/Python_%EC%84%A4%EC%B9%98.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/Python_%EC%84%A4%EC%B9%98/Python_%EC%84%A4%EC%B9%98.html"
  },"19": {
    "doc": "Python 설치",
    "title": "Python 다운로드",
    "content": ". | 홈페이지 접속 python.org -&gt; Download -&gt; All releases | Looking for a specific release? 에서 원하는 버전 Download 선택 | Files -&gt; Windows 의 경우 Windows Installer (64-bit) 선택하여 다운로드 | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/Python_%EC%84%A4%EC%B9%98/Python_%EC%84%A4%EC%B9%98.html#python-%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/Python_%EC%84%A4%EC%B9%98/Python_%EC%84%A4%EC%B9%98.html#python-다운로드"
  },"20": {
    "doc": "Python 설치",
    "title": "Python 설치",
    "content": ". | Python 설치 Add python.exe to PATH 를 선택하면 현재 설치하는 버전의 Python 이 환경변수에 설정된다. 설치 완료 시 Disable path length limit 을 선택해준다. 설치 완료 | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/Python_%EC%84%A4%EC%B9%98/Python_%EC%84%A4%EC%B9%98.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/Python_%EC%84%A4%EC%B9%98/Python_%EC%84%A4%EC%B9%98.html"
  },"21": {
    "doc": "Python 설치",
    "title": "설치 버전 확인",
    "content": ". | 버전 확인 C:\\Users\\ME&gt;python --version Python 3.12.9 . | 설치된 모든 버전 확인 C:\\Users\\ME&gt;py -0 -V:3.13 * Python 3.13 (64-bit) -V:3.12 Python 3.12 (64-bit) . | 설치된 모든 버전과 설치 경로 확인 C:\\Users\\ME&gt;py -0p -V:3.13 * C:\\Users\\ME\\AppData\\Local\\Programs\\Python\\Python313\\python.exe -V:3.12 C:\\Users\\ME\\AppData\\Local\\Programs\\Python\\Python312\\python.exe . | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/Python_%EC%84%A4%EC%B9%98/Python_%EC%84%A4%EC%B9%98.html#%EC%84%A4%EC%B9%98-%EB%B2%84%EC%A0%84-%ED%99%95%EC%9D%B8",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/Python_%EC%84%A4%EC%B9%98/Python_%EC%84%A4%EC%B9%98.html#설치-버전-확인"
  },"22": {
    "doc": "SOLID 원칙",
    "title": "SOLID 원칙",
    "content": "SOLID 는 로버트 C. 마틴Robert C. Martin이 제안한 다섯 가지 설계 원칙의 약어로, 소프트웨어를 보다 이해하기 쉽고 유연하며 유지보수가 용이하도록 만드는 것을 목표로 한다. 이번 장에서 다룰 주요 주제는 다음과 같다. | 단일 책임 원칙SRP: Single Responsibility Principle | 개방-폐쇄 원칙OCP: Open-Closed Principle | 리스코프 치환 원칙LSP: Liskov Substitution Principle | 인터페이스 분리 원칙ISP: Interface Segregation Principle | 의존성 역전 원칙DIP: Dependency Inversion Principle | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/SOLID_%EC%9B%90%EC%B9%99.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/SOLID_%EC%9B%90%EC%B9%99.html"
  },"23": {
    "doc": "SOLID 원칙",
    "title": "단일 책임 원칙 (SRP)",
    "content": "SRP 는 소프트웨어 설계의 기본 개념으로, 기능을 제공하는 클래스를 정의할 때 그 클래스는 단 하나의 이유로 존재해야 하며, 기능의 한 측면에 대해서만 책임을 져야 한다고 주장한다. 간단히 말해서, 각 클래스는 하나의 작업 또는 책임만을 가져야 하며, 그 작업은 클래스 내부에 캡슐화되어야 한다는 것이다. SRP 를 준수하면 보다 집중적이고 응집력 있으며 전문화된 기능을 가진 클래스를 추구하게 된다. 이러한 접근 방식은 코드 베이스의 유지보수성과 이해도를 향상시키는 데 중요한 역할을 한다. 각 클래스가 명확하고 단일한 목적을 가지게 되면, 코드를 관리/이해/확장하는 것이 쉬워진다. 실제로 SRP 를 적용하면, 작은 규모의 집중된 클래스로 이어지게 되며, 이 클래스들은 조합되어 복잡한 시스템을 구성하면서도 명확하고 체계적인 구조를 유지할 수 있다. NOTE SRP 는 클래스의 코드 라인 수를 최소화하는 것이 아니라, 클래스가 변경되어야 하는 단일 이유를 보장함으로써 수정 시 의도치 않은 부작용의 가능성을 줄이는 데 초점을 맞춘다. 예제 - SRP 를 따르는 소프트웨어 설계 . SRP 를 따르지 않은 전형적인 코드 예제를 먼저 보자. class Report: def __init__(self, content): self.content = content def generate(self): print(f\"Report content: {self.content}\") def save_to_file(self, filename): with open(filename, \"w\") as file: file.write(self.content) . 위 예제의 Report 클래스는 보고서를 생성하는 것과 파일에 저장하는 두 가지 책임을 가지고 있다. 물론 이렇게 구현해도 동작은 하겠지만, 설계 원칙은 미래의 요구사항 변화와 복잡성 증대에 대비해 개선을 고민하도록 한다. SRP 는 이러한 상황에서 책임을 분리하라고 가르친다. SRP 를 준수하기 위해, 코드를 다음과 같이 두 개의 클래스로 리팩토링 할 수 있다. class Report: def __init__(self, content): self.content = content def generate(self): print(f\"Report content: {self.content}\") class ReportSaver: def __init__(self, report: Report): self.report: Report = report def save_to_file(self, filename: str): with open(filename, \"w\") as file: file.write(self.report.content) if __name__ == '__main__': # Report, ReportSaver 클래스가 정상적으로 동작하는지 확인하기 위한 테스트 report_content = \"This is the content.\" report = Report(report_content) report.generate() report_saver = ReportSaver(report) report_saver.save_to_file('report.txt') . Report content: This is the content. 리포트 파일도 정상적으로 생성되었고, 저장된 내용은 다음과 같다. This is the content. | Report 클래스는 보고서 내용을 생성하는 역할만 담당함. | ReportSaver 클래스는 Report 클래스에서 생성한 보고서를 파일에 저장하는 역할을 담당함. | 이 예제에서 보듯, SRP 를 따르면 책임이 분리된 더 깔끔하고 유지보수가 용이하며 적응력 있는 코드를 작성할 수 있음. | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/SOLID_%EC%9B%90%EC%B9%99.html#%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99-srp",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/SOLID_%EC%9B%90%EC%B9%99.html#단일-책임-원칙-srp"
  },"24": {
    "doc": "SOLID 원칙",
    "title": "개방-폐쇄 원칙 (OCP)",
    "content": "OCP 는 클래스나 모듈 같은 소프트웨어 엔티티가 확장을 위해서는 열려 있어야 하지만, 수정(변경)에는 닫혀 있어야 한다고 강조한다. 이는 한 번 정의되고 구현된 소프트웨어 엔티티는 새로운 기능을 추가하기 위해 직접 수정되어서는 안 된다는 의미이다. 대신, 상속이나 인터페이스를 통해 해당 엔티티를 확장하여 새로운 요구사항과 동작을 수용해야 한다. 예제 - OCP 를 따르는 설계 . Rectangle 클래스를 정의했다고 가정해 보자. 예를 들어, 다양한 도형의 면적을 계산하는 기능을 추가한다고 했을 때, 초기 가설적 코드에서는 Report 와 비슷하게 Rectangle 클래스와 이를 처리하는 caculate_area 함수를 아래와 같이 정의한다. class Rectangle: def __init__(self, width: float, height: float): self.width: float = width self.height: float = height def cacluate_area(shape) -&gt; float: if isinstance(shape, Rectangle): return shape.width * shape.height . 여기서 한 가지 문제는 새로운 도형을 추가하려면 cacluate_area 함수를 수정해야 한다는 점이다. 이는 유지보수 관점에서 이상적이지 않다. 왜냐하면 코드를 반복적으로 수정하게 되면, 다른 부분에 영향을 주어 버그가 발생할 위험이 있기 때문이다. 더 나은 설계를 위해 OCP 를 따르도록 코드를 개선해 보았다. 여기서는 Circle 클래스를 추가하여 도형 인터페이스를 확장하는 방법을 보여준다. import math from typing import Protocol class Shape(Protocol): def area(self) -&gt; float: ... class Rectangle: def __init__(self, width: float, height: float): self.width: float = width self.height: float = height def area(self): return self.width * self.height class Circle: def __init__(self, radius: float): self.radius: float = radius def area(self) -&gt; float: return math.pi * (self.radius ** 2) def calculate_area(shape: Shape) -&gt; float: return shape.area() if __name__ == '__main__': rect = Rectangle(12, 8) rect_area = calculate_area(rect) print(f\"Rectangle area: {rect_area:.2f}\") circle = Circle(6.5) circle_area = calculate_area(circle) print(f\"Circle area: {circle_area:.2f}\") . Rectangle area: 96.00 Circle area: 132.73 . 위 에제에서는 Protocol 을 사용하여 각 도형이 스스로 면적을 계산하도록 구현하였으므로, 새로운 도형을 추가할 때 기존 코드를 수정할 필요 없이 확장할 수 있음을 보여준다. | Shape 프로토콜을 정의하여 모든 도형이 area 메서드를 구현하도록 요구함. | Rectangle 과 Circle 클래스는 각각 area 메서드를 구현하여 Shape 인터페이스를 만족함. | calculate_area 함수는 Shape 인터페이스를 기반으로 동작하여, 어떤 도형이 들어오더라도 해당 도형의 area 메서드를 호출함. | Ractangle 과 Circle 클래스에서 크기를 구하는 area 를 구현했으므로 caculate_area 함수는 추가되는 도형에 대해 수정할 필요가 없음. | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/SOLID_%EC%9B%90%EC%B9%99.html#%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99-ocp",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/SOLID_%EC%9B%90%EC%B9%99.html#개방-폐쇄-원칙-ocp"
  },"25": {
    "doc": "SOLID 원칙",
    "title": "리스코프 치환 원칙 (LSP)",
    "content": "LSP 는 서브클래스가 슈퍼클래스와 어떻게 관련되어야 하는지를 규정한다. LSP 에 따르면, 프로그램이 슈퍼클래스의 객체를 사용할 때, 해당 객체를 서브클래스의 객체로 대체해도 프로그램의 올바른 동작과 기대되는 행동이 변경되어서는 안된다. LSP 는 상속을 사용할 때, 서브클래스가 부모 클래스의 외부 동작을 변경하지 않고 확장해야 함을 보장한다. 예를 들어, 어떤 함수가 슈퍼클래스 객체와 함께 올바르게 작동한다면, 해당 슈퍼클래스의 서브클래스 객체와도 동일하게 작동해야 한다. 예제 - LSP 를 따르는 소프트웨어 설계 . Bird 클래스를 상속하는 Penguin 클래스를 예로 들어 보자. class Bird: def fly(self): print('I can fly') class Penguin(Bird): def fly(self): print('I can\\'t fly') def make_bird_fly(bird): bird.fly() . 현재 코드에서 Bird 클래스의 인스턴스를 함수에 전달하면 기대하는 동작이 나타나지만, Penguin 클래스의 인스턴스를 전달하면 다른 동작이 발생한다. 이로 인해 make_bird_fly 함수에서 일관된 동작을 보장하지 못한다. 다음 예제 코드는 이에 대한 개선 방안이다. class Bird: def move(self): print('I\\'m moving') class FlyingBird(Bird): def move(self): print('I\\'m flying') class FlightlessBird(Bird): def move(self): print('I\\'m walking') def make_bird_move(bird): bird.move() if __name__ == '__main__': generic_bird = Bird() eagle = FlyingBird() penguin = FlightlessBird() make_bird_move(generic_bird) make_bird_move(eagle) make_bird_move(penguin) . I'm moving I'm flying I'm walking . | Bird 클래스에 move 메소드를 도입하여 모든 새가 움직임을 가지도록 하고, FlyingBird 와 FlightlessBird 클래스로 분리해 각각 날거나 걷는 동작을 구현함. | FlyingBird 와 FlightlessBird 클래스는 슈퍼클래스인 Bird 의 역할을 대체할 수 있어, 프로그램의 예상 동작이 유지 됨. | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/SOLID_%EC%9B%90%EC%B9%99.html#%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99-lsp",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/SOLID_%EC%9B%90%EC%B9%99.html#리스코프-치환-원칙-lsp"
  },"26": {
    "doc": "SOLID 원칙",
    "title": "인터페이스 분리 원칙 (ISP)",
    "content": "ISP 는 크고 범용적인 인터페이스보다는 더 작고 구체적인 인터페잇스를 설계할 것을 권장한다. 이 원칙은 한 클래스가 자신이 사용하지 않는 인터페이스를 강제로 구현하도록 강요받아서는 안 된다고 말한다. 파이썬 맥락에서는 클래스가 자신의 목적과 관련 없는 메서드를 상속받거나 구현할 필요가 없어야 한다는 것을 의미한다. 즉, 소프트웨어를 설계할 때 큰 단일 인터페이스를 만드는 대신, 작고 집중된 인터페이스를 만드는 것이 바람직하다. 이렇게 하면 클래스는 필요한 것만 상속받거나 구현하게 되어, 각 클래스에 관련성 있고 필수적인 메서드만 포함되도록 할 수 있다. 이 원칙을 따르면 소프트웨어의 모듈성, 코드 가독성 및 유지보수성이 향상되며, 부수 효과가 줄어들고 리팩토링과 테스트가 용이한 소프트웨어를 구축할 수 있다. 예제 - ISP 를 따르는 소프트웨어 설계 . 예를 들어, 인쇄, 스캔, 팩스 기능을 모두 제공하는 AllInOnePrinter 클래스가 있다고 가정해 보자. 이 클래스는 아래와 같이 정의된다. class AllInOnePrinter: def print_document(self): print('Printing') def scan_document(self): print('Scanning') def fax_document(self): print('Faxing') . 여기서 만약 단순히 인쇄만 하는 기능의 SimplePrinter 클래스를 만들고 싶다면, AllInOnePrinter 처럼 스캔과 팩스 기능까지 구현하거나 상속받아야 한다. 이는 이상적이지 않다. ISP 를 따르기 위해서는 각 기능별로 별도의 인터페이스를 만들어, 각 클래스가 자신에게 필요한 인터페이스만 구현하도록 해야 한다. 아래 코드는 위의 문제를 ISP 로 개선한 예제이다. from typing import Protocol class Printer(Protocol): def print_document(self): ... class Scanner(Protocol): def scan_document(self): ... class Fax(Protocol): def fax_document(self): ... class AllInOnePrinter: def print_document(self): print('Printing') def scan_document(self): print('Scanning') def fax_document(self): print('Faxing') class SimplePrinter: def print_document(self): print('Simply Printing') def do_the_print(printer: Printer): printer.print_document() if __name__ == '__main__': all_in_one = AllInOnePrinter() all_in_one.scan_document() all_in_one.fax_document() do_the_print(all_in_one) simple = SimplePrinter() do_the_print(simple) . Scanning Faxing Printing Simply Printing . | Printer, Scanner, Fax 와 같은 작은 인터페이스(Protocol)을 정의하여, 각 클래스가 필요한 기능만 구현하도록 함. | AllInOnePrinter 는 모든 인터페이스를 구현하고, SimplePrinter 는 인쇄 기능만 구현하게 되어, 각 클래스가 자신의 역할에 충실함. | 이를 통해 모듈성이 향상되고, 불필요한 의존성이 줄어들어 코드 유지보수성이 개선됌. | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/SOLID_%EC%9B%90%EC%B9%99.html#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99-isp",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/SOLID_%EC%9B%90%EC%B9%99.html#인터페이스-분리-원칙-isp"
  },"27": {
    "doc": "SOLID 원칙",
    "title": "의존성 역전 원칙 (DIP)",
    "content": "DIP 는 고수준 모듈이 저수준 모듈에 직접 의존해서는 안 되며, 대신 둘 다 추상화나 인터페이스에 의존해야 한다고 주장한다. 이렇게 하면 고수준 구성 요소를 저수준 구성 요소의 세부 사항으로부터 분리할 수 있다. 예제 - DIP 를 따르는 소프트웨어 설계 . 먼저, 이메일을 통해 알림을 보내는 Notification 클래스를 생각해 보자. 원래 코드는 Email 클래스에 직접 의존하는 방식으로 작성되어 있다. class Email: def send_email(self, message): print(f'Sending email: {message}') class Notification: def __init__(self): self.email = Email() def send(self, message): self.email.send_email(message) . 현재 Notification 클래스는 저수준 모듈인 Email 클래스에 직접 의존하고 있는데, 이는 이상적이지 않다. 이를 개선하기 위해 DIP 를 적용하여 추상화를 도입해보자. from typing import Protocol class MessageSender(Protocol): def send(self, message: str): ... class Email: def send(self, message: str): print(f\"Sending email: {message}\") class Notification: def __init__(self, sender: MessageSender): self.sender = sender def send(self, message: str): self.sender.send(message) if __name__ == '__main__': email = Email() notif = Notification(sender=email) notif.send(message='This is the message') . | MessageSender 인터페이스(Protocol)를 도입하여, Notification 클래스가 MessageSender 인터페이스를 통해 메시지를 전송하도록 변경. | Notification 과 Email 모두 MessageSender 에 의존하게 되어, Notification 은 Email 의 구체적인 구현에 영향을 받지 않으며, DIP 를 준수하게 됨. | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/SOLID_%EC%9B%90%EC%B9%99.html#%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99-dip",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/SOLID_%EC%9B%90%EC%B9%99.html#의존성-역전-원칙-dip"
  },"28": {
    "doc": "Home",
    "title": "Welcome to github.io",
    "content": "Github Description . ",
    "url": "/#welcome-to-githubio",
    
    "relUrl": "/#welcome-to-githubio"
  },"29": {
    "doc": "Home",
    "title": "Get started now View it on GitHub",
    "content": " ",
    "url": "/#get-started-now-view-it-on-github",
    
    "relUrl": "/#get-started-now-view-it-on-github"
  },"30": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"31": {
    "doc": "개인 웹사이트",
    "title": "개인 웹사이트",
    "content": "본 장에서는 홈페이지와 소개 페이지를 포함하는 개인 웹사이트를 구축하면서 Django 의 템플릿, 함수 기반 뷰function-based views, 그리고 테스트testing에 대해 더 깊이 학습할 것이다. 템플릿은 데이터가 어떻게 표시되는지를 제어하는 표현 계층presentation layers이며, 템플릿 상속template inheritance과 기본 로직을 포함하여 Django 의 “반복하지 마라”Don’t Repeat Yourself, DRY원칙을 따른다. 뷰는 URL 과 템플릿을 결합하고, 데이터 처리에 필요한 로직을 추가하는 역할로 Django 애플리케이션의 로직 레이어로 여겨진다. 마지막으로 테스트는 모든 웹 프로젝트에서 필수적이며 Django 에서 잘 지원된다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B0%9C%EC%9D%B8_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B0%9C%EC%9D%B8_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html"
  },"32": {
    "doc": "개인 웹사이트",
    "title": "초기 설치",
    "content": "Hello World 웹사이트에서 사용하던 venv 를 사용하며, Django 프로젝트는 새로 구성한다. &gt; mkdir personal_website &gt; cd personal_website &gt; django-admin startproject django_project . &gt; python manage.py startapp pages . pages 앱을 추가한 후 Django 가 이를 인식하도록 django_project/settings.py 파일의 INSTALLED_APPS 리스트에 pages 를 추가한다. django_project/settings.py . INSTALLED_APPS = [ \"django.contrib.admin\", \"django.contrib.auth\", \"django.contrib.contenttypes\", \"django.contrib.sessions\", \"django.contrib.messages\", \"django.contrib.staticfiles\", \"pages\", ] . &gt; python manage.py migrate &gt; python manage.py runserver . ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B0%9C%EC%9D%B8_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%EC%B4%88%EA%B8%B0-%EC%84%A4%EC%B9%98",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B0%9C%EC%9D%B8_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#초기-설치"
  },"33": {
    "doc": "개인 웹사이트",
    "title": "홈페이지",
    "content": "Django 의 뷰는 웹 요청Web request를 받아 웹 응답Web response을 반환하는 파이썬 함수이다. 웹 페이지가 요청되면 Django 는 자동으로 요청에 관한 메타 데이터를 포함한 HttpRequest 객체를 생성한다. 이후 뷰는 HttpResponse 객체를 반환한다. 이전 장에서 했던 단계를 반복하여, 단순히 뷰와 URL 디스패처를 사용해 홈페이지를 만드는 작업을 시작할 것이다. 그 후 템플릿과 보다 복잡한 뷰 로직을 활용해 소개 페이지를 만들 예정이다. 먼저 뷰부터 시작해 보자. pages/views.py . from django.shortcuts import render # Create your views here. 소개 페이지를 위해 render 함수를 사용할 예정이므로, 해당 임포트는 그대로 두면 된다. 홈페이지를 위해 이전 장의 단계를 반복하여, HttpResponse 클래스를 임포트하고 home_page_view 라는 이름의 뷰를 생성한다. 첫 번째 매개변수의 이름은 request 로 하고, “Homepage” 라는 텍스트를 반환한다. pages/views.py . from django.http import HttpResponse from django.shortcuts import render # Create your views here. def home_page_view(request): return HttpResponse(\"Homepage\") . 다음 단계는 pages 앱 내에 urls.py 파일을 생성하는 것이다. 이 파일에서는 django.urls 모듈로부터 path 함수를, 그리고 현재 디렉터리의 views.py 파일로부터 home_page_view 를 임포트한 후, 빈 문자열 \"\" 에 해당하는 경로를 설정하여 home_page_view 를 호출한다. pages/urls.py . from django.urls import path from .views import home_page_view urlpatterns = [ path(\"\", home_page_view) ] . 마지막 단계는 모든 URL 요청의 초기 진입점인 프로젝트 레벨의 urls.py 파일을 업데이트 하는 것이다. 다른 URL 설정을 포함하기 위해 include 함수를 임포트하고, pages 애플리케이션에 대해 빈 문자열 \"\" 경로를 설정한다. django_project/urls.py . from django.contrib import admin from django.urls import path, include urlpatterns = [ path(\"admin/\", admin.site.urls), path(\"\", include(\"pages.urls\")) ] . 로컬 서버를 실행하고 http://localhost:8000 에 접속하면 다음과 같은 화면이 뜬다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B0%9C%EC%9D%B8_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%ED%99%88%ED%8E%98%EC%9D%B4%EC%A7%80",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B0%9C%EC%9D%B8_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#홈페이지"
  },"34": {
    "doc": "개인 웹사이트",
    "title": "함수 기반 뷰를 활용한 소개 페이지",
    "content": "render 함수는 템플릿 작업에 유용한 Django 의 단축 함수shorcut function 이다. render 함수의 첫 번째 매개변수는 HttpRequest 객체이고, 두 번째 매개변수는 템플릿 이름 이다. 즉 about.html 템플릿을 사용하여 소개 페이지를 위한 뷰를 생성하고자 한다면 다음과 같이 작성할 수 있다. pages/views.py . from django.http import HttpResponse from django.shortcuts import render # Create your views here. def home_page_view(request): return HttpResponse(\"Homepage\") def about_page_view(request): return render(request, \"pages/about.html\") . 새로 추가된 뷰인 about_page_view 함수는 는 첫 번째 매개변수로 HttpRequest 객체를 받고, render 함수를 사용하여 request 객체와 연관된 “pages/about.html” 템플릿을 반환한다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B0%9C%EC%9D%B8_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%ED%95%A8%EC%88%98-%EA%B8%B0%EB%B0%98-%EB%B7%B0%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%86%8C%EA%B0%9C-%ED%8E%98%EC%9D%B4%EC%A7%80",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B0%9C%EC%9D%B8_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#함수-기반-뷰를-활용한-소개-페이지"
  },"35": {
    "doc": "개인 웹사이트",
    "title": "템플릿",
    "content": "템플릿은 Django 에서 표현 계층으로 작동하며, HTML 파일을 생성하는 편리한 방법을 제공한다. 이 HTML 파일에는 CSS, JavaScript, 이미지와 같은 미디어도 포함될 수 있다. 기본적으로 Django 의 템플릿 로딩 엔진은 각 앱 내의 templetes 서브디렉토리를 검색한다. 예를 들면, pages 앱 내부에 templates 디렉터리를 추가하고 그안에 about.html 파일을 두면 다음과 같은 구조가 된다. └── pages ├── templates ├── about.html . 이 방식도 동작하지만 최선의 방법은 아니다. 왜냐하면 Django 는 이름이 일치하는 첫 번째 템플릿을 사용하기 때문에, 만약 두개의 다른 앱에 about.html 파일이 있다면 어떤 파일을 사용할지 명확하지 않기 때문이다. 이 문제를 해결하기 위한 간단한 방법은 템플릿 파일을 애플리케이션 이름을 포함하는 별도의 디렉터리에 두어 네임스페이스namespace를 부여하는 것이다. 즉, 다음과 같은 구조를 사용한다. app/templates/app/template_file . pages 앱의 경우, 구조는 아래와 같이 변경된다. └── pages ├── templates ├── pages ├── about.html . Django 의 모범 사례로 앱 내에 템플릿 파일을 저장할 때는 항상 이와 같이 네임스페이스를 적용하는 것이 좋다. 템플릿 생성을 위해 디렉터리를 생성해보자. &gt; mkdir pages/templates/pages . 그리고 나서 pages/templates/pages 디렉터리 내에 about.html 파일을 생성한다. about.html 안에 내용은 다음과 같이 작성한다. pages/templates/pages/about.html . &lt;h1&gt;About page&lt;/h1&gt; &lt;p&gt;This is the new template-powered About pages.&lt;/p&gt; . 이렇게 템플릿 파일이 완성되면, about_page_view 함수는 해당 템플릿에 접근할 수 있게 되지만, 마지막으로 URL 디스패처를 구성하는 단계가 남았다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B0%9C%EC%9D%B8_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%ED%85%9C%ED%94%8C%EB%A6%BF",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B0%9C%EC%9D%B8_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#템플릿"
  },"36": {
    "doc": "개인 웹사이트",
    "title": "URL 디스패처",
    "content": "이제 새로운 URL 경로를 추가하는 패턴이 익숙해지기 시작할 것이다. 우선, 뷰 함수인 about_page_view 를 임포트한 후, 해당 경로를 “about/” 으로 설정하고 뷰 이름을 지정한다. pages/urls.py . from django.urls import path from .views import home_page_view, about_page_view urlpatterns = [ path(\"about/\", about_page_view), path(\"\", home_page_view) ] . 이제 로컬 서버를 실행하고, http://localhost:8000/about/ 에 접속하면 About 페이지가 표시된다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B0%9C%EC%9D%B8_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#url-%EB%94%94%EC%8A%A4%ED%8C%A8%EC%B2%98",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B0%9C%EC%9D%B8_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#url-디스패처"
  },"37": {
    "doc": "개인 웹사이트",
    "title": "Django 템플릿 언어",
    "content": "모든 웹 프레임워크는 HTML 을 동적으로 생성할 방법이 필요하며, 가장 일반적인 방법은 정적 콘텐츠와 동적 콘텐츠를 삽입할 수 있는 특별한 문법을 포함한 템플릿을 사용하는 것이다. Django 는 Vue, React, Angular 와 같은 전용 JavaScript 프론트엔드를 대체하려는 것이 아니라, 주석, 변수, 필터, 태그, 템플릿 상속 등을 활용하는 의도적으로 제한적이지만 강력한 방법을 제공한다. 우리가 만든 about.html 템플릿을 다시 살펴보며 이러한 기능들을 사용해 보자. 우선, 주석 태그를 사용하면 개발자가 읽을 수 있도록 코드를 추가할 수 있으면서도 해당 내용은 페이지에 표시되지 않는다. `` 태그 사이에 있는 모든 내용은 무시된다. pages/templates/pages/about.html . &lt;h1&gt;About page&lt;/h1&gt; . 파일을 저장하고 웹 브라우저를 새로고침하면, 주석 내용은 렌더링된 HTML 에 포함되지 않아 화면에 나타나지 않는다. 다중 행 주석을 추가할 때도 같은 comment 태그를 사용할 수 있으나, Django 템플릿은 가능한 한 단순하게 유지하는 것이 좋다. 기본적인 로직을 포함시키는 것은 허용되지만, 복잡한 처리 로직은 뷰나 모델 파일로 옮기는 것이 바람직한다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B0%9C%EC%9D%B8_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#django-%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%96%B8%EC%96%B4",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B0%9C%EC%9D%B8_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#django-템플릿-언어"
  },"38": {
    "doc": "개인 웹사이트",
    "title": "테스트",
    "content": "코드를 작성하는 것만큼 테스트를 작성하는 것도 중요하다. 테스트가 동반되지 않는다면, 오픈 소스 프로젝트나 잘 구조화된 기업 내에서 새로운 코드 변경사항을 제출할 수 없다. 이유는 간단하다. 코드 변경이 작더라도 프로젝트의 다른 부분을 의도치 않게 깨뜨릴 가능성이 있기 때문이다. 좋은 테스트를 작성하면 코드베이스에 대한 신뢰성을 높일 수 있고, 작성 시간도 많이 들지 않으며, 새로운 코드 변경 시 자동으로 실행할 수 있도록 자동화할 수 있다. 테스트는 크게 단위 테스트Unit Tests와 통합 테스트Integration Tests로 나뉜다. 단위 테스트는 기능의 한 조각을 독립적으로 확인하고, 통합 테스트는 여러 연결된 부분들을 함께 점검한다. 단위 테스트는 코드의 일부분만 다루므로 실행 속도가 빠르고 유지보수가 쉽지만, 통합 테스트는 실행 속도가 느리고 문제 발생 시 원인을 특정하기 어렵다. 대부분의 개발자들은 단위 테스트를 많이 작성하고, 통합 테스트는 적게 작성하는 경향이 있다. 테스트할 내용을 결정하는 문제도 중요하다. 새로운 기능을 추가할 때마다 해당 기능이 의도대로 작동하는지 확인하는 테스트를 작성해야 한다. 예를 들어, 우리가 만든 프로젝트에는 홈페이지와 소개 페이지가 있으므로, 이 두 페이지가 예상한 URL 에서 정상적으로 HTTP 200 상태 코드를 반환하는지 테스트할 필요가 있다. 프로젝트가 커질수록 변경될 가능성이 있는 부분을 미리 점검하는 것이 중요하다. Python 표준 라이브러리에는 unittest 라는 내장 모듈이 포함되어 있으며, TestCase 인스턴스와 다양한 assert 메서드를 통해 실패를 확인하고 보고한다. Django 의 테스트 프레임워크는 Python 의 unittest.TestCase 를 확장한 여러 기능들을 제공한다. 여기에는 더미 웹 브라우저 요청을 위한 테스트 클라이언트, Django 전용 추가 assertion, 그리고 네 가지 테스트 케이스 클래스(SimpleTestCase, TestCase, TransactionTestCase, LiveServerTestCase)가 포함된다. | SimpleTestCase: 데이터베이스가 필요 없는 테스트에 사용 | TestCase: 데이터베이스 관련 테스트에 사용 | TransactionTestCase: 데이터베이스 트랜잭션을 직접 테스트할 때 유용 | LiveServerTestCase: Selenium 과 같은 브라우저 기반 도구로 테스트할 때, 실제 서버 스레드를 실행함 | . 참고 사항으로 unittest 와 django.test 의 메서드들이 Python 의 일반적인 snake_case 대신 camelCase 로 작성된 이유는, Python 의 unittest 가 Java 의 jUnit 테스트 프레임워크를 기반으로 하고 있기 때문이다. pages 앱 내부에는 이미 Django 가 제공한 test.py 파일이 있다. 이번 프로젝트는 데이터베이스가 관여하지 않으므로, 파일 상단에서 SimpleTestCase 를 임포트 한다. 그리고 첫 테스트로 홈페이지와 소개 페이지의 URL 이 각각 HTTP 200 상태 코드를 반환하는지 확인해본다. pages/tests.py . from django.test import SimpleTestCase # Create your tests here. class HomePageTest(SimpleTestCase): def test_url_exists_at_correct_location(self): response = self.client.get('/') self.assertEqual(response.status_code, 200) class AboutpageTests(SimpleTestCase): def test_url_exists_at_correct_location(self): response = self.client.get('/about/') self.assertEqual(response.status_code, 200) . 실행중인 서버를 중지하고 테스트를 실행했을 때 OK 메시지가 있으면 테스트에 성공한 것이다. &gt; python manage.py test Found 2 test(s). System check identified no issues (0 silenced).. ---------------------------------------------------------------------- Ran 2 tests in 0.015s OK . ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B0%9C%EC%9D%B8_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%ED%85%8C%EC%8A%A4%ED%8A%B8",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B0%9C%EC%9D%B8_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#테스트"
  },"39": {
    "doc": "객체지향 파이썬 프로그래밍",
    "title": "객체지향 파이썬 프로그래밍",
    "content": " ",
    "url": "/docs/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5_%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5_%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html",
    
    "relUrl": "/docs/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5_%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5_%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.html"
  },"40": {
    "doc": "구조 디자인 패턴",
    "title": "구조 디자인 패턴",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EA%B5%AC%EC%A1%B0_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B5%AC%EC%A1%B0_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EA%B5%AC%EC%A1%B0_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B5%AC%EC%A1%B0_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4.html"
  },"41": {
    "doc": "기본 디자인 원칙",
    "title": "기본 디자인 원칙",
    "content": ". | 변하는 부분은 캡슐화 하라Encapsulate What Varies | 상속보다 합성을 우선하라Favor Composition Over Inheritance | 구현이 아닌 인터페이스에 맞춰 프로그래밍하라Program to Interfaces, Not Implementations | 느슨한 결합Loose Coupling | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/%EA%B8%B0%EB%B3%B8_%EB%94%94%EC%9E%90%EC%9D%B8_%EC%9B%90%EC%B9%99.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/%EA%B8%B0%EB%B3%B8_%EB%94%94%EC%9E%90%EC%9D%B8_%EC%9B%90%EC%B9%99.html"
  },"42": {
    "doc": "기본 디자인 원칙",
    "title": "변하는 부분은 캡슐화 하라",
    "content": "이 원칙의 핵심 아이디어는 변화가 가장 자주 일어날 가능성이 있는 코드 부분을 분리하여 캡슐화 하는 것이다. 이렇게 하면 변경될 가능성이 있는 요소들로부터 나머지 코드를 보호하는 방어막을 형성하게 되고, 한 부분을 수정하더라도 다른 부분에 영향을 최소화할 수 있다. 장점 . | 유지보수의 용이성Ease of maintenence 변경이 필요할 때 캡슐화된 부분만 수정하면 되므로, 다른 영역에 버그가 발생할 위험이 줄어든다. | 유연성 향상Enhanced flexibility 캡슐화된 구성 요소는 쉽게 교체하거나 확장할 수 있어, 보다 적응력 있는 아키텍쳐를 제공한다. | 가독성 개선Improved readability 변화하는 요소들을 분리함으로써 코드가 보다 체계적이고 이해하기 쉬워진다. | . 필요한 테크닉 . | 다형성Polymorphism | 세터와 게터Getters and Setters | @property Decorator | . 예제 - 다형성을 사용한 캡슐화 예시 . 다음은 각 결제 방식을 별도로 별도의 클래스로 캡슐화 하는 예시이다. class PaymentBase: def __init__(self, amount: int): self.amount = amount def process_payment(self): pass class CreditCard(PaymentBase): def process_payment(self): msg = f\"Credit card payment: {self.amount}\" print(msg) class PayPal(PaymentBase): def process_payment(self): msg = f\"Paypal payment: {self.amount}\" print(msg) if __name__ == \"__main__\": payments = [CreditCard(100), PayPal(200)] for payment in payments: payment.process_payment() . Credit card payment: 100 Paypal payment: 200 . | 각 결제 방식을 별도의 클래스로 분리하여 캡슐화 | PaymentBase 라는 기본 클래스에서 process_payment() 메서드를 정의하고, 이를 상속받은 CreditCard 와 Paypal 클래스에서 구체적인 결제 로직을 구현 | 다형성을 사용하여 여러 결제 객체를 동일한 인터페이스로 처리할 수 있어, 결제 방식이 변경되더라도 핵심 로직에는 영향을 주지 않음 | . 예제 - @property 를 활용한 캡슐화 . class Circle: def __init__(self, radius: int): self._radius: int = radius @property def radius(self): return self._radius @radius.setter def radius(self, value: int): if value &lt; 0: raise ValueError(\"Radius cannot be negative!\") self._radius = value if __name__ == \"__main__\": circle = Circle(10) print(f\"Initial radius: {circle.radius}\") circle.radius = 15 print(f\"New radius: {circle.radius}\") . Initial radius: 10 New radius: 15 . | 내부 속성 보호: 실제 데이터는 _radius에 저장되며, 외부에는 radius 속성을 통해 노출되어 직접적인 접근을 막음. | 검증 로직 포함: setter 메서드에서 반지름 값이 음수가 될 경우 예외를 발생시켜, 잘못된 값이 설정되지 않도록 보장함. | 유연한 코드 유지: _radius 검증 로직이 변경되더라도 외부 인터페이스는 그대로 유지되므로, 클래스 사용자에게 영향을 주지 않음. | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/%EA%B8%B0%EB%B3%B8_%EB%94%94%EC%9E%90%EC%9D%B8_%EC%9B%90%EC%B9%99.html#%EB%B3%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84%EC%9D%80-%EC%BA%A1%EC%8A%90%ED%99%94-%ED%95%98%EB%9D%BC",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/%EA%B8%B0%EB%B3%B8_%EB%94%94%EC%9E%90%EC%9D%B8_%EC%9B%90%EC%B9%99.html#변하는-부분은-캡슐화-하라"
  },"43": {
    "doc": "기본 디자인 원칙",
    "title": "상속보다 합성을 우선하라",
    "content": "상속은 장점이 있지만, 너무 밀접하게 결합된 코드가 되어 유지보수나 확장이 어려워질 수 있다. 이런 문제를 해결하기 위해 합성Composition 을 우선하라는 원칙이 등장했다. 장점 . | 유연성Flexibility 합성을 사용하면 런타임 시에 객체의 행동을 변경할 수 있어 코드가 더욱 적응력 있게 된다. | 재사용성Reusability 더 작고 단순한 객체들을 애플리케이션의 다양한 부분에서 재사용할 수 있어 코드 재사용성이 증대된다. | 유지보수 용이성Ease of maintenance 합성을 사용하면 전체 시스템에 영향을 주지 않고 개별 구성 요소를 쉽게 교체하거나 업데이트할 수 있어, 경계 효과border effect를 피할 수 있다. | . 필요한 테크닉 . | has-a | . 예제 - 엔진을 사용하여 자동차 구성하기 . 파이썬에서는 클래스 내부에 다른 클래스의 인스턴스를 포함시켜 합성을 구현할 수 있다. 다음은 Engine 클래스를 포함하는 Car 클래스이다. class Engine: def start(self): print(\"Engine started\") class Car: def __init__(self): self.engine = Engine() def start(self): self.engine.start() print(\"Car started\") if __name__ == '__main__': my_car = Car() my_car.start() . Engine started Car started . | Car 클래스 초기화에서 Engine 인스턴스를 생성하고, start() 메서드에서 엔진의 start() 메서드를 호출한 후 자동차 시작 메시지를 출력했다. | 엔진을 다른 종류로 교체할 수 있어, Car 클새스 자체를 수정하지 않고도 구성 요소를 유연하게 변경 가능하다. | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/%EA%B8%B0%EB%B3%B8_%EB%94%94%EC%9E%90%EC%9D%B8_%EC%9B%90%EC%B9%99.html#%EC%83%81%EC%86%8D%EB%B3%B4%EB%8B%A4-%ED%95%A9%EC%84%B1%EC%9D%84-%EC%9A%B0%EC%84%A0%ED%95%98%EB%9D%BC",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/%EA%B8%B0%EB%B3%B8_%EB%94%94%EC%9E%90%EC%9D%B8_%EC%9B%90%EC%B9%99.html#상속보다-합성을-우선하라"
  },"44": {
    "doc": "기본 디자인 원칙",
    "title": "구현이 아닌 인터페이스에 맞춰 프로그래밍하라",
    "content": "소프트웨어 설계에서는 기능이 어떻게 구현되는지에 집착하기 쉽다. 하지만 구현 세부사항에 너무 집중하면 코드가 서로 밀접하게 결합되어 수정하기 어려워진다. 이 문제에 대한 해결책으로 “구현이 아닌 인터페이스에 맞춰 프로그래밍하라” 원칙이 제시된다. 인터페이스는 클래스에 대해 반드시 구현해야 하는 메서드 집합이라는 계약을 정의한다. 이 원칙은 구체적인 클래스 대신 인터페이스를 기준으로 코드를 작성하도록 권장한다. 이를 통해 필요한 기능을 제공하는 특정 클래스에 의존하지 않게 되어, 나중에 구현을 교체하거나 확장할 때 전체 시스템에 미치는 영향을 최소화할 수 있다. 장점 . | 유연성Flexibility 사용되는 코드를 수정하지 않고도 다양한 구현체 간에 쉽게 전환할 수 있다. | 유지보수성Maintainability 특정 구현체에 종속되지 않으므로 구성 요소를 업데이트하거나 교체하기가 용이하다. | 테스트 용이성Testability 인터페이스를 모의mock하여 단위 테스트를 쉽게 작성할 수 있다. | . 필요한 테크닉 . | Abstract base classes (ABCs) | protocols | . Abstract base classes (ABCs) . 파이썬의 abc 모듈에서 제공하는 ABCs 를 사용하면, 모든 구체적인 서브클래스가 반드시 구현해야 하는 추상 메서드를 정의할 수 있다. 아래 코드는 이 개념에 대한 적용 예제이다. from abc import ABC, abstractmethod class MyInterface(ABC): @abstractmethod def do_somthing(self, param: str): pass class MyClass(MyInterface): def do_somthing(self, param: str): print(f\"Doing something with: '{param}'\") MyClass().do_somthing('some param') . Doing something with: 'some param' . Protocols . typing 모듈의 Protocols 는 실제 상속 관계와 상관없이 객체가 특정 속성이나 메서드를 가지고 있다면 유효한 것으로 간주하는 구조적 덕 타이핑structural duck typing을 제공한다. 전통적인 덕 타이핑에서는 타입 호환성이 런타임에 결정되지만, 구조적 덕 타이핑을 사용하면 컴파일 타임에 타입 검사가 가능해진다. 이를 통해 코드가 실행되기 전에 타입 오류를 미리 잡아낼 수 있어, 프로그램의 견고함과 디버깅 용이성이 크게 향상된다. Protocols 의 핵심 장점은 객체가 무엇을 할 수 있는지에 초점을 맞춘다는 점이다. 어떤 객체가 오리처럼 걷고 오리처럼 꽥꽥거린다면, 실제 상속 관계에 상관없이 그 객체는 오리로 간주된다. 이는 객체의 행동이 실제 타입보다 중요한 파이썬과 같은 동적 타이핑 언어에서 특히 유용하다. 예를 들어, draw 메서드를 요구하는 Drawable 프로토콜을 정의할 수 있다. 이 경우, draw 메서드를 구현하는 모든 클래스는 명시적으로 해당 프로토콜을 상속받지 않더라도 암묵적으로 프로토콜을 만족하게 된다. 만약, fly 메서드를 요구하는 Flyer 라는 Protocol 이 필요하다고 가정하면, 다음과 같이 정의할 수 있다. from typing import Protocol class Flyer(Protocol): def fly(self) -&gt; None: ... 이렇게 하면, fly 메서드를 가진 모든 클래스는 명시적으로 Flyer 를 상속하지 않더라도 Flyer 로 간주된다. 이는 보다 일반적이고 재사용 가능한 코드를 작성할 수 있게 해주며, 앞서 논의한 “상속보다 합성을 선호하라” 원칙과도 일맥상통하다. 예제 - ABC 를 사용한 다양한 유형의 로거 . from abc import ABC, abstractmethod class Logger(ABC): @abstractmethod def log(self, message: str): pass class ConsoleLogger(Logger): def log(self, message: str): print(f'Console: {message}') class FileLogger(Logger): def log(self, message: str): with open('log.txt', 'a') as f: f.write(f\"File: {message}\\n\") def log_message(logger: Logger, message: str): logger.log(message) if __name__ == '__main__': log_message(ConsoleLogger(), 'A Console log.') log_message(FileLogger(), 'A file log.') . Console: A console log. 생성된 log.txt 파일을 열어보면 아래와 같은 내용이 기록된다. File: A file log. | log_message 함수를 통해 로깅 매커니즘을 손쉽게 전환할 수 있으며, 함수 자체의 코드는 변경할 필요가 없다. | . 예제 - Protocol 를 사용한 다양한 타입의 로거 . from typing import Protocol class Logger(Protocol): def log(self, message: str): ... class ConsoleLogger: def log(self, message: str): print(f'Console: {message}') class FileLogger: def log(self, message: str): with open('log.txt', 'a') as f: f.write(f'File: {message}\\n') def log_message(logger: Logger, message: str): logger.log(message) if __name__ == '__main__': log_message(ConsoleLogger(), \"A console log.\") log_message(FileLogger(), 'A file log.') . Console: A console log. ABC 를 사용했을 때와 마찬가지로 log.txt 파일에는 다음의 내용이 추가된다. File: A file log. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/%EA%B8%B0%EB%B3%B8_%EB%94%94%EC%9E%90%EC%9D%B8_%EC%9B%90%EC%B9%99.html#%EA%B5%AC%ED%98%84%EC%9D%B4-%EC%95%84%EB%8B%8C-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%97%90-%EB%A7%9E%EC%B6%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%ED%95%98%EB%9D%BC",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/%EA%B8%B0%EB%B3%B8_%EB%94%94%EC%9E%90%EC%9D%B8_%EC%9B%90%EC%B9%99.html#구현이-아닌-인터페이스에-맞춰-프로그래밍하라"
  },"45": {
    "doc": "기본 디자인 원칙",
    "title": "느슨한 결합",
    "content": "소프트웨어의 복잡성이 증가함에 따라, 구성 요소 간의 관계가 뒤얽히기 쉬워져 전체 시스템을 이해하고 유지보수하며 확장하기 어려워진다. 느슨한 결합loose coupling 원칙은 이러한 문제를 완화하는 데 목적이 있다. 느슨한 결합은 프로그램의 서로 다른 부분 간의 의존성을 최소화하는 것을 의미한다. 느슨하게 결합된 시스템에서는 구성 요소들이 독립적으로 존재하며, 명확하게 정의된 인터페이스를 통해 상호작용하기 때문에 한 부분을 변경해도 다른 부분에 미치는 영향을 최소화할 수 있다. 장점 . | 유지보수성Maintainability 의존성이 적어 개별 구성 요소를 업데이트하거나 교체하기가 쉬워진다. | 확장성Extensibility 새로운 기능이나 구성 요소를 시스템에 쉽게 추가할 수 있다. | 테스트 용이성Testability 독립적인 구성 요소들은 개별적으로 테스트하기 용이하여 전체 소프트웨어 품질을 향상시킨다. | . 필요한 테크닉 . | 의존성 주입Dependency injection | 옵저버 패턴Observer Pattern | . 예제 - 메시지 서비스 . class MessageService: def __init__(self, sender): self.sender = sender def send_message(self, message: str): self.sender.send(message) class EmailSender: def send(self, message: str): print(f\"Sending email: {message}\") class SMSSender: def send(self, message: str): print(f\"Sending SMS: {message}\") if __name__ == \"__main__\": email_service = MessageService(EmailSender()) email_service.send_message(\"Hello via Email\") sms_service = MessageService(SMSSender()) sms_service.send_message(\"Hello via SMS\") . Sending email: Hello via Email Sending SMS: Hello via SMS . | 이 예제에서는 MessageService 가 EmailSender 와 SMSSender 와 느슨하게 결합되어 있다. 의존성 주입을 통해 MessageService 클래스 자체를 수정하지 않고도 다양한 전송 매커니즘을 쉽게 전환할 수 있다. | MessageService 가 직접 전송 방식을 구현하지 않고, 외부에서 주입받은 sender 객체를 이용하는 덕분에, 새로운 전송 매커니즘을 추가하거나 기존 매커니즘을 교체하는 것이 매우 용이하다. 이렇게 하면 각 구성 요소의 독립성이 보장되어 유지보수와 확장이 한결 수월해진다. | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/%EA%B8%B0%EB%B3%B8_%EB%94%94%EC%9E%90%EC%9D%B8_%EC%9B%90%EC%B9%99.html#%EB%8A%90%EC%8A%A8%ED%95%9C-%EA%B2%B0%ED%95%A9",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/%EA%B8%B0%EB%B3%B8_%EB%94%94%EC%9E%90%EC%9D%B8_%EC%9B%90%EC%B9%99.html#느슨한-결합"
  },"46": {
    "doc": "기본 원칙",
    "title": "기본 원칙",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99/%EA%B8%B0%EB%B3%B8_%EC%9B%90%EC%B9%99.html"
  },"47": {
    "doc": "기업 웹사이트",
    "title": "기업 웹사이트",
    "content": "이번 장에서는 템플릿에 대해 더 깊이 배우고, 클래스 기반 뷰class-based views를 도입하여, 고급 테스트 기법을 통합하는 과정을 통해 기업 웹사이트를 구축할 것이다. 이 프로젝트는 데이터베이스와 Django 보델로 넘어가기 전 마지막 프로젝트로, 지금까지 배운 내용을 복습하고 Django 의 나머지 세 가지 핵심 요소(views, URLs, templates)가 어떤 역할을 하는지 탐구할 기회이다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html"
  },"48": {
    "doc": "기업 웹사이트",
    "title": "초기 설정",
    "content": "venv 는 이전에 만든 것을 재사용한다. 코드 작업을 위한 새 디렉터리인 company 를 생성하고 해당 디렉터리로 이동한다. &gt; mkdir company &gt; cd company . 다음으로 새 장고 프로젝트를 django_project 라는 이름으로 생성하고, pages 라는 앱을 추가한다. 여기서 모든 앱 이름을 pages 로 사용하는 이유는 상대적으로 정적인 페이지를 다루기 때문이며, 향후 데이터베이스를 활용해 동적으로 페이지를 구성할 때는 앱이름을 다르게 할 수 있다. &gt; django-admin startproject django_project . &gt; python manage.py startapp pages . pages 앱이 Django 에 인식되도록, django_project/settings.py 파일의 INSTALLED_APPS 리스트에 pages 를 추가한다. django_project/settings.py . INSTALLED_APPS = [ \"django.contrib.admin\", \"django.contrib.auth\", \"django.contrib.contenttypes\", \"django.contrib.sessions\", \"django.contrib.messages\", \"django.contrib.staticfiles\", \"pages\" ] . 데이터베이스를 초기화하고 로컬 웹 서버를 시작하자. &gt; python manage.py migrate &gt; python manage.py runserver . 웹 브라우저에서 http://localhost:8000 를 접속하면 Django welcome 페이지를 볼 수 있을 것이다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%EC%B4%88%EA%B8%B0-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#초기-설정"
  },"49": {
    "doc": "기업 웹사이트",
    "title": "프로젝트 레벨 템플릿",
    "content": "이전에는 Django 가 각 앱 내의 templates 디렉터리에 템플릿 파일이 위치하기를 기대한다는 것을 보았다. 예를 들어, pages 앱의 템플릿 파일은 보통 pages/templates/pages/ 에 위치한다. 그러나 많은 Django 개발자들은 모든 템플릿을 한 곳에서 관리할 수 있도록 단일 프로젝트 레벨의 templates 디렉터리를 만드는 방식을 선호한다. 이렇게 하면 모든 템플릿을 한 위치에서 찾아 업데이트하기가 더 쉬워진다. django_project/settings.py 파일을 약간 수정하여 Django 가 이 디렉터리에서 템플릿을 찾도록 설정할 수 있다. 먼저, 실행 중인 서버를 중지하고, templates 디렉터리를 생성하자. &gt; mkdir templates . 다음 단계로 django_project/settings.py 파일의 TEMPLATES 설정 내 “DIRS” 항목을 수정하여 새 템플릿 디렉터리의 위치를 알려준다. django_project/settings.py . TEMPLATES = [ { \"BACKEND\": \"django.template.backends.django.DjangoTemplates\", \"DIRS\": [BASE_DIR / \"templates\"], # new \"APP_DIRS\": True, \"OPTIONS\": { \"context_processors\": [ \"django.template.context_processors.debug\", \"django.template.context_processors.request\", \"django.contrib.auth.context_processors.auth\", \"django.contrib.messages.context_processors.messages\", ], }, }, ] . templates 디렉터리 내에 home.html 이라는 새 파일을 생성한다. 앞으로는 이 방식을 사용하여 템플릿을 구성한다. 생성한 home.html 파일에는 간단한 제목을 추가한다. &lt;h1&gt;Company Homepage&lt;/h1&gt; . 다음 단계는 URL 과 뷰, 파일을 설정하는 것이다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%A0%88%EB%B2%A8-%ED%85%9C%ED%94%8C%EB%A6%BF",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#프로젝트-레벨-템플릿"
  },"50": {
    "doc": "기업 웹사이트",
    "title": "함수 기반 뷰와 URL",
    "content": "뷰를 먼저 작성할지 URL 부터 작성할지는 전적으로 개발자에게 달려 있따. 결국 웹 페이지를 표시하기 위해서는 뷰와 URL 설정 둘 다 필요하므로 실행 순서는 개인 취향에 따라 결정하면 된다. 여기서는 pages 앱 내에 뷰 부터 작성한다. pages/views.py . from django.shortcuts import render # Create your views here. def home_page_view(request): # new return render(request, \"home.html\") . 이 코드는 이전 장에서 보았던 render 단축 함수를 사용한다. home_page_view 를 생성할 때, 첫 번째 매개변수(HttpRequest 객체인 request)를 받고, home.html 템플릿 파일을 렌더링하여 반환한다. 다음으로, 프로젝트 레벨과 앱 레벨의 URL 파일을 설정한다. 프로젝트의 django_project/urls.py 파일은 모든 URL 요청의 초기 진입점이다. 여기서 include 함수를 임포트하고, pages 앱의 URL 라우트를 빈 문자열(\"\")에 포함시킨다. django_project/urls.py . from django.contrib import admin from django.urls import path, include # new urlpatterns = [ path(\"admin/\", admin.site.urls), path(\"\", include(\"pages.urls\")) # new ] . 앱 레벨인 pages/urls.py 파일에서는 home_page_view 를 입포트하고, 빈 문자열 (\"\") 경로에 연결한다. pages/urls.py . from django.urls import path from .views import home_page_view urlpatterns = [ path(\"\", home_page_view) ] . Django 를 실행하고 http://localhost:8000/ 에 접속하면 다음과 같이 Company Homepage 가 나타나는 걸 볼 수 있다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%ED%95%A8%EC%88%98-%EA%B8%B0%EB%B0%98-%EB%B7%B0%EC%99%80-url",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#함수-기반-뷰와-url"
  },"51": {
    "doc": "기업 웹사이트",
    "title": "템플릿 컨텍스트, 태그, 필터",
    "content": "홈페이지에 템플릿 컨텍스트를 추가하고 Django 의 내장 태그와 필터들을 활용해보자. 태그는 반복문, 조건문, 템플릿 상속과 같이 보다 복잡한 동작을 수행하는 반면, 필터는 날짜 포맷 변경, 텍스트 자르기, 문자열 대문자 변환 등과 같이 변수의 표시 형식을 단순하게 수정하는 데 사용된다. 기억해야 할 태그와 필터의 종류가 너무 많기 때문에, 원하는 거의 모든 콘텐츠 표시 작업에 대해 Django 가 기본 제공 솔루션을 갖추고 있다는 점을 인지하는 것이 중요하다. 예시로, 템플릿 컨텍스트는 키와 값으로 구성된 딕셔너리 형태이다. 여기서는 두 개의 항목을 추가한다. | inventory_list: 세 개의 위젯을 포함하는 리스트 | greeting: 대소문자가 섞인 인사말 문자열 | . pages/views.py . from django.shortcuts import render # Create your views here. def home_page_view(request): context = { # new \"inventory_list\": [\"Widget 1\", \"Widget 2\", \"Widget 3\"], \"greeting\": \"thaNK yOU fOR viSitiNG\" } return render(request, \"home.html\", context) . home.html 템플릿 파일은 다음과 같이 업데이트한다. &lt;h1&gt;Company Homepage&lt;/h1&gt; &lt;p&gt;The current date and time is: {% now \"DATETIME_FORMAT\" %}&lt;/p&gt; &lt;p&gt;There are {{ inventory_list|length }} items of inventory.&lt;/p&gt; &lt;ul&gt; {% for item in inventory_list %} &lt;li&gt;{{ item.name }}&lt;/li&gt; {% endfor %} &lt;/ul&gt; &lt;p&gt;{{ greeting|title }}&lt;/p&gt; {% comment %}Add more content here!{% endcomment %} . | &lt;h1&gt;&lt;/h1&gt; : 헤더 태그 | &lt;p&gt;&lt;/p&gt;: paragraph 약자로 하나의 문단을 정의한다. 이 태그는 앞뒤로 자동으로 줄바꿈을 생성하므로, 문단 구분에 유용하다. | &lt;ul&gt;&lt;/ul&gt;: 정렬되지 않은 리스트 | &lt;li&gt;&lt;/li&gt;: 리스트안에 존재하는 요소 | {% now \"DATETIME_FORMAT\" %}: 현재 날짜와 시간을 표시한다. | ``: 리스트의 길이를 표시한다. | {% for item in inventory_list %} ~ {% endfor %}: 리스트의 각 항목을 반복하고, {% endfor %} 로 반복문을 종료한다. | ``: greeting 문자열을 각 단어의 첫 글자는 대문자, 나머지는 소문자로 변환한 뒤 표시한다. | ``: HTML 에 출력되지 않는 주석을 추가한다. | . 실행 중인 웹 브라우저 페이지를 새로 고침하여 변경 사항을 확인할 수 있다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%ED%83%9C%EA%B7%B8-%ED%95%84%ED%84%B0",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#템플릿-컨텍스트-태그-필터"
  },"52": {
    "doc": "기업 웹사이트",
    "title": "클래스 기반 뷰Class-Based Views와 제네릭 클래스 기반 뷰Generic Class-Based Views",
    "content": "Django 커뮤니티에서는 오랫동안 함수 기반 뷰와 클래스 기반 뷰 사이의 논쟁이 있었다. 초기 Django 버전은 함수 기반 뷰만 제공했는데, 이들은 HTTP 요청/응답 사이클을 그대로 모방하여 이해하기 쉽다는 장점이 있다. 하지만 함수 기반 뷰에는 단점이 있다. 상속을 통한 코드 재사용이 어려워, 개발자가 동일한 코드 조각을 여러 뷰에서 반복하게 되는데, 이는 Django 의 DRY 원칙에 위배된다. 또한, 실제 프로젝트에서는 함수 기반 뷰가 10 줄, 20 줄 이상의 로직으로 길어져 이해하기 어려워질 수 있다. 초기 Django 개발 단계에서는 이러한 문제를 해결하기 위해 제네릭 함수 기반 뷰가 도입되어 공통 패턴을 추상화하고 코드 중복을 줄였다. 예를 들어 . | 단일 템플릿을 표시하는 뷰 작성 | 데이터베이스 모델의 모든 객체를 나열하는 뷰 작성 | 모델의 한 항목을 상세하게 표시하는 뷰 작성 | 객체를 생성, 수정, 삭제하는 뷰 작성 | . 하지만 제네릭 함수 기반 뷰는 확장하거나 커스터마이징하기 어렵다는 문제점이 있었고, 프로젝트가 커질수록 그 한계가 드러났다. 이후 Django 는 콛르 재사용성을 높이고자 클래스 기반 뷰와 제네릭 클래스 기반 뷰를 도입했다. 클래스는 Python 의 객체 지향 프로그래밍에서 상속을 통해 속성과 메서드를 재사용할 수 있는 기본 개념이므로, 뷰의 공통 롲익을 하나의 클래스에 추상화하고 필요에 따라 확장하거나 수정할 수 있다. 제네릭 클래스 기반 뷰를 사용하면 보통 하나의 메서드만 오버라이드하여 커스터마이징할 수 있으므로, 처음부터 모든 코드를 새로 작성할 필요가 없고, 다른 사람의 코드를 이해하기도 쉬워진다. 다만, 내부 동작을 완전히 이해하는 데는 시간이 걸리고 복잡성이 증가한다는 단점도 있다. 실제로 Django 개발자들을 위해 제네릭 클래스 기반 뷰를 해독하는 전용 웹사이트인 Classy Class-Based Views 가 운영되고 있다. Django 코드베이스 자체도 주로 클래스 기반 및 제네릭 클래스 기반 뷰로 전황되었으며, 제네릭 함수 기반 뷰는 Django 1.3 에서 더 이상 사용되지 않고deprecated 1.5 버전에서 완전히 제거되었다. 결과적으로, Django 에서는 뷰를 작성하는 세 가지 방식이 존재한다. | 함수 기반 | 클래스 기반 | 제네릭 클래스 기반 | . 이 세 가지 방식에 대한 접근 방식을 이해하는 것이 중요하며, 시간이 지나면서 개인적인 선호도에 따라 선택하게 될 것이다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B8%B0%EB%B0%98-%EB%B7%B0class-based-views%EC%99%80-%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B8%B0%EB%B0%98-%EB%B7%B0generic-class-based-views",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#클래스-기반-뷰class-based-views와-제네릭-클래스-기반-뷰generic-class-based-views"
  },"53": {
    "doc": "기업 웹사이트",
    "title": "템플릿 뷰",
    "content": "이번에는 제네릭 클래스 기반 뷰인 TemplateView 를 사용하여, 기업 웹페이지의 두 번째 페이지인 About 페이지를 생성해본다. 이 페이지는 템플릿 컨텍스트와 Django 템플릿 언어의 기능을 함께 활용한다. 먼저, pages/views.py 파일 상단에서 django.views.generic 모듈로부터 TemplateView 를 임포트한다. 그런 다음, TemplateView 를 상속받은 클래스를 생성하고, 템플릿 이름을 about.html 로 지정한다. pages/views.py . from django.shortcuts import render from django.views.generic import TemplateView # new # Create your views here. def home_page_view(request): context = { \"inventory_list\": [\"Widget 1\", \"Widget 2\", \"Widget 3\"], \"greeting\": \"thaNK yOU fOR viSitiNG\" } return render(request, \"home.html\", context) class AboutPageView(TemplateView): # new template_name = \"about.html\" . 다음으로, pages/urls.py 파일을 업데이트한다. AboutPageView 를 임포트한 후, about/ 경로에 대해 AboutPageView.as_view() 를 사용하여 라우트를 설정한다. pages/urls.py . from django.urls import path from .views import home_page_view, AboutPageView # new urlpatterns = [ path(\"about/\", AboutPageView.as_view()), # new path(\"\", home_page_view) ] . 여기서 주목할 점은, 클래스 기반 뷰를 URL 에 연결할 때 반드시 as_view() 메서드를 호출해야 한다는 것이다. 이 메서드는 클래스 기반 뷰를 호출 가능한 함수로 변환해 준다. 마지막 단계는 템플릿 파일을 생성하는 것이다. 기존의 templates 디렉터리 내에 about.html 파일을 만들고 다음의 코드를 입력한다. templates/about.html . &lt;h1&gt;Company About Pages&lt;/h1&gt; . 로컬 서버가 실행중이면 웹 브라우저에서 http://localhost:8000/about/ 으로 접속하여 새로운 About 페이지를 확인할 수 있다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%B7%B0",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#템플릿-뷰"
  },"54": {
    "doc": "기업 웹사이트",
    "title": "get_context_data() 메서드",
    "content": "Django 에서 가장 강력하고 유용하며 자주 사용되는 메서드 중 하나인 get_context_data() 를 사용해보는 시간을 갖는다. 제네릭 클래스 기반 뷰에서 템플릿 컨텍스트를 업데이트하는 권장 방법이다. 이번에는 이 메서드를 오버라이드하여 About 페이지에 추가적인 컨텍스트 데이터를 제공해본다. pages/views.py ... class AboutPageView(TemplateView): # new template_name = \"about.html\" def get_context_data(self, **kwargs): # new context = super().get_context_data(**kwargs) context[\"contact_address\"] = \"123 Main Street\" context[\"phone_number\"] = \"555-555-5555\" return context ... 먼저 기존의 get_context_data() 메서드를 오버라이드한다. 첫 번째 매개변수는 self 이며, 두 번째는 **kwargs 로 키워드 인자를 전달할 수 있게 해준다. 이렇게 하면 컨텍스트에 새로운 키/쌍 값을 추가할 수 있다. 다음으로 super().get_context_data(**kwargs) 를 호출하여 기존 컨텍스트 값을 변수 context 에 저장한다. 이후, context 딕셔너리에 contact_address 와 phone number 라는 두 개의 키와 그에 해당하는 값을 추가한다. 마지막으로 업데이트된 context 를 명시적으로 반환한다. 템플릿에서는 이 컨텍스트 변수들을 출력하기 위해 중괄호 두 쌍(``)을 사용한다. templates/about.html . &lt;h1&gt;Company About Pages&lt;/h1&gt; &lt;p&gt;The company address is and the phone number is .&lt;/p&gt; . 웹 브라우저에서 About 페이지를 새로고침하면, 추가된 정보가 화면에 표시되는 것을 확인할 수 있다. 사용 시점에는 제네릭 클래스 기반 뷰가 불필요해 보일 수 있지만, 다음 장에서 데이터베이스와 함께 작업할 때 그 진정함 힘이 드러날 것이다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#get_context_data-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#get_context_data-메서드"
  },"55": {
    "doc": "기업 웹사이트",
    "title": "템플릿 상속Template Inheritance",
    "content": " ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%83%81%EC%86%8Dtemplate-inheritance",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#템플릿-상속template-inheritance"
  },"56": {
    "doc": "기업 웹사이트",
    "title": "추가 자료",
    "content": ". | Classy Class-Based Views | . ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%EC%B6%94%EA%B0%80-%EC%9E%90%EB%A3%8C",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EA%B8%B0%EC%97%85_%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8.html#추가-자료"
  },"57": {
    "doc": "데이터의 연산",
    "title": "데이터의 연산",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html"
  },"58": {
    "doc": "데이터의 연산",
    "title": "개요",
    "content": "이번 섹션에서는 데이터를 다루는 데 필요한 다양한 연산자와 기능을 소개한다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#개요"
  },"59": {
    "doc": "데이터의 연산",
    "title": "산술 연산자 (Arithmetic operators)",
    "content": "산술연산자는 수학적인 연산을 수행하기 위해 사용되는 기호이다. 파이썬의 산술연산자와 기능을 아래 표에 정리해 보았다. | 연산자 | 의미 | 예시 | 결과 | . | + | 덧셈 | 5 + 2 | 7 | . | - | 뺄셈 | 5 - 2 | 3 | . | * | 곱셈 | 5 * 2 | 10 | . | / | 나눗셈 | 5 / 2 | 2.5 | . | // | 몫 | 5 // 2 | 2 | . | % | 나머지 | 5 % 2 | 1 | . | ** | 거듭제곱 | 5 ** 2 | 25 | . 예제 - 문자열의 연산 . 산술 연산은 숫자에만 사용 가능한 것은 아니다. 다음은 문자열과 문자열의 덧셈, 문자열과 숫자를 곱셈하는 예제이다. hello = \"안녕하세요\" some_number = 3 print(hello + hello + hello) print(hello * some_number) print(some_number * hello) . &gt;&gt;&gt; 안녕하세요안녕하세요안녕하세요 안녕하세요안녕하세요안녕하세요 안녕하세요안녕하세요안녕하세요 . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0%EC%9E%90-arithmetic-operators",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#산술-연산자-arithmetic-operators"
  },"60": {
    "doc": "데이터의 연산",
    "title": "연산자 우선순위",
    "content": "연산자에는 우선순위가 정해져 있다. 산술 연산자의 경우에 ** 이 가장 높은 우선순위를 가지며, *, /, //, % 가 그 다음으로 높으며, +, - 가 가장 낮은 우선순위를 갖는다. 이 외 연산자에 대한 우선순위는 추가 자료 &gt; 연산자 우선순위 를 참고한다. 복잡한 계산 경우 괄호(())를 사용해 그룹화하여 연산자 우선순위를 조금 더 단순화 할 수 있다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#%EC%97%B0%EC%82%B0%EC%9E%90-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#연산자-우선순위"
  },"61": {
    "doc": "데이터의 연산",
    "title": "복합 연산자 (Augmented assignment)",
    "content": "코드의 간결함을 위해 파이썬은 복합 연산자를 지원한다. 변수 &lt;산술연산자&gt;= 식 형태이며 이는 내부적으로 변수 = 변수 &lt;산술연산자&gt; 식 과 동일한 결과를 낳는다. 단, 좌측의 변수는 사전에 정의 되어 있어야 한다. | 연산자 | 의미 | . | **= | 변수의 값에 우측 값을 거듭제곱한 결과를 변수에 대입한다. | . | *= | 변수의 값에 우측 값을 곱한 결과를 변수에 대입한다. | . | /= | 변수의 값을 우측 값으로 나눈 결과를 변수에 대입한다. | . | //= | 변수의 값을 우측 값으로 나눈 결과의 몫을 변수에 대입한다. | . | %= | 변수의 값을 우측 값으로 나눈 결과의 나머지를 변수에 대입한다. | . | += | 변수의 값에 우측 값을 더한 결과를 변수에 대입한다. | . | -= | 변수의 값에서 우측 값을 뺀 결과를 변수에 대입한다. | . 예제 - 복합 연산자 . x = 3 y = 5 print('연산 전:', x) x *= y # x = x * y 와 같다. print(' 연산 후:', x) . &gt;&gt;&gt; 연산 전: 3 연산 후: 15 . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#%EB%B3%B5%ED%95%A9-%EC%97%B0%EC%82%B0%EC%9E%90-augmented-assignment",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#복합-연산자-augmented-assignment"
  },"62": {
    "doc": "데이터의 연산",
    "title": "비교 연산자 (Comparison operators)",
    "content": "비교 연산자는 두 값(또는 객체)을 비교한 결과를 불리언 값(True 또는 False) 로 반환한다. 값, 객체의 동일성, 멤버쉽 테스트로 분류할 수 있다. | 표현 | 의미 | 분류 | . | x &lt; y | x 값이 y 값 보다 작으면 True 를 반환 | 값 | . | x &gt; y | x 값이 y 값 보다 크면 True 를 반환 | 값 | . | x == y | x 값이 y 값과 같으면 True 를 반환 | 값 | . | x &gt;= y | x 값이 y 값 보다 크거나 같으면 True 를 반환 | 값 | . | x &lt;= y | x 값이 y 값 보다 작거나 같으면 True 를 반환 | 값 | . | x != y | x 값이 y 값과 다르면 True 를 반환 | 값 | . | x is y | x 와 y 와 동일한 객체이면 True 를 반환 | 객체의 동일성 | . | x is not y | x 와 y 가 동일한 객체가 아니면 True 를 반환 | 객체의 동일성 | . | x in y | y가 반복 가능한(iterable) 객체일 때, x가 그 멤버 중 하나이면 True를 반환한다. | 멤버쉽 테스트 | . | x not in y | y가 반복 가능한(iterable) 객체일 때, x가 그 멤버에 포함되어 있지 않으면 True를 반환한다. | 멤버쉽 테스트 | . 예제 - 비교 연산자 . a = 3 b = 5 print(\"a = 3\\nb = 5\\n\") print(\"a &lt; b:\", a &lt; b) print(\"a &gt; b:\", a &gt; b) print(\"a == b:\", a == b) print(\"0 &lt; a &lt; 100:\", 0 &lt; a &lt; 100) . &gt;&gt;&gt; a = 3 b = 5 a &lt; b: True a &gt; b: False a == b: False 0 &lt; a &lt; 100: True . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90-comparison-operators",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#비교-연산자-comparison-operators"
  },"63": {
    "doc": "데이터의 연산",
    "title": "논리 연산자 (Boolean operators)",
    "content": "논리 연산자는 피 연산자의 불리언 값을 평가하여, 조건식의 결과를 결정한다. x or y . | x 의 불리언 값이 True 이면 x 를 반환한다. y 는 평가하지 않는다. | x 의 불리언 값이 False 인 경우 y 를 반환한다. | . x and y . | x 의 불리언 값이 False 이면 x 를 반환한다. | x 의 불리언 값이 True 이면 y 를 반환한다. y 는 평가하지 않는다. | . not x . | x 의 불리언 값이 False 이면 True 를 반환한다. | x 의 불리언 값이 True 이면 False 를 반환한다. | . 표현식이나 객체가 불리언 평가될 때의 결과를 확인하려면 bool 함수를 사용할 수 있다. 예를 들어 print(bool(15 &gt; 3)) 은 True 를 출력하고, print(bool(15 &lt; 3)) 은 False 를 출력한다. 예제 - 논리 연산자 (표현식) . a = 0 b = 5 print(a and b) print(a or b) print(not a) . &gt;&gt;&gt; 0 5 True . 예제 - 논리 연산자 (비교연산자 포함) . a = 0 b = 5 print((a == 1) and (a &lt; b)) print((a == 1) or (a &lt; b)) print(not (a == 0)) . &gt;&gt;&gt; False True False . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#%EB%85%BC%EB%A6%AC-%EC%97%B0%EC%82%B0%EC%9E%90-boolean-operators",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#논리-연산자-boolean-operators"
  },"64": {
    "doc": "데이터의 연산",
    "title": "데이터의 형 변환",
    "content": "자료형을 다른 형태로 변환하는 것을 형 변환(Type conversion)이라고 한다. 명시적 형 변환 . str, int 등과 같은 클래스를 사용해 명시적으로 자료형을 변환할 수 있다. 예제 - 명시적 형 변환 . user_number = input(\"숫자를 입력해 주세요: \") print(user_number + \" * 3 =\", int(user_number) * 3) . &gt;&gt;&gt; 숫자를 입력해 주세요: 100 100 * 3 = 300 . 암묵적 형 변환 . 서로 다른 자료형 간의 연산에서 자동으로 형 변환이 수행될 수 있다. 예를 들어, 정수와 부동 소수점을 연산하게 되면 정수를 자동으로 부동 소수점으로 변환한뒤 계산한다. 예제 - 암묵적 형 변환 . integer = 3 float_point = 5.0 result = integer + float_point print(result) print(type(result)) . &gt;&gt;&gt; 8.0 &lt;class 'float'&gt; . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-%ED%98%95-%EB%B3%80%ED%99%98",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#데이터의-형-변환"
  },"65": {
    "doc": "데이터의 연산",
    "title": "연습문제",
    "content": "연습문제1 . 다음 연산의 결과를 예상해 보십시오. 3 + 2 * -1 ** 2 . 연습문제2 . 터미널에 어떤 결과가 출력될지 예상해 보십시오. a = int(\"10000\") b = int(\"10000\") print(a == b) print(a is b) . 연습문제3 . 터미널에 어떤 결과가 출력될지 예상해 보십시오. a = 0 b = \"3\" if (a == 0) or (a + b): print(a) . 연습문제4 . 사용자로부터 섭씨 온도를 입력받아, 이를 화씨 온도로 변환하는 프로그램을 작성해 보시오. 화씨 온도를 구하는 공식은 다음과 같습니다. 화씨 온도 = (섭씨 온도 * 9/5) + 32 * 섭씨 : celsius * 화씨 : fahrenheit ##### 예시 ##### 섭씨 온도: 44 섭씨 온도 44°C 는 화씨 온도 111.2°F 입니다. ################ . 연습문제5 . 체질량지수(bmi)는 자신의 몸무게(kg)를 키의 제곱(m)으로 나눈 값입니다. 사용자의 몸무게(kg), 키(m) 를 입력받아 체질량지수를 출력하는 프로그램을 만들어 보십시오. ##### 예시 ##### 몸무게(kg) 를 입력하십시오 : 64.3 키(m) 를 입력하십시오 : 1.69 당신의 체질량 지수는 ??? 입니다. ################ 참고 사이트 : https://health.seoulmc.or.kr/healthCareInfo/myBMIPopup.do . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#연습문제"
  },"66": {
    "doc": "데이터의 연산",
    "title": "추가 자료",
    "content": ". | 연산자 우선순위 | 복합 연산자 | 비교 연산자 | 논리 연산자 | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#%EC%B6%94%EA%B0%80-%EC%9E%90%EB%A3%8C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98_%EC%97%B0%EC%82%B0.html#추가-자료"
  },"67": {
    "doc": "리스트",
    "title": "리스트",
    "content": "파이썬은 여러 값을 함께 묶어 관리할 수 있는 다양한 복합 자료형compound data types을 지원한다. 이번 섹션에서는 복합 자료형 중 가장 다재다능한 자료형인 리스트를 알아본다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html"
  },"68": {
    "doc": "리스트",
    "title": "리스트 생성하기",
    "content": "리스트는 대괄호([])안에 쉼표(,)로 구분된 값들을 나열하여 작성할 수 있다. 리스트 안의 개별적인 값은 요소element 또는 항목item이라고 한다. 리스트 안에는 서로 다른 타입의 값도 포함할 수 있다. 다만, 데이터의 일관성을 위해 필요에 따라 동일한 타입을 사용하는 것이 좋다. fibonacci_numbers = [0, 1, 1, 2, 3, 5, 8, 13, 21] print(fibonacci_numbers) . &gt;&gt;&gt; [0, 1, 1, 2, 3, 5, 8, 13, 21] . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#리스트-생성하기"
  },"69": {
    "doc": "리스트",
    "title": "특정 항목 가져오기",
    "content": "문자열이나 다른 시퀀스 자료형과 마찬가지로 리스트는 인덱싱과 슬라이싱을 지원하며, 이 기능들로 특정 항목을 가져올 수 있다. 다음의 인덱싱, 슬라이싱 예제는 앞서 보았던 fibonacci_numbers 변수를 그대로 사용한다. fibonacci_numbers = [0, 1, 1, 2, 3, 5, 8, 13, 21] print(fibonacci_numbers[3]) print(fibonacci_numbers[-1]) . &gt;&gt;&gt; 2 21 . 슬라이싱의 경우 새로운 리스트를 반환한다. fibonacci_numbers = [0, 1, 1, 2, 3, 5, 8, 13, 21] print(fibonacci_numbers[2:6]) print(fibonacci_numbers[-4:]) . &gt;&gt;&gt; [3, 5, 8, 13] [5, 8, 13, 21] . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#%ED%8A%B9%EC%A0%95-%ED%95%AD%EB%AA%A9-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#특정-항목-가져오기"
  },"70": {
    "doc": "리스트",
    "title": "리스트의 산술 연산",
    "content": "리스트에서 가능한 몇 가지 산술 연산을 알아본다. 리스트와 리스트는 + 연산자를 사용하여 결합할 수 있다. squares1 = [1, 4, 9, 16] squares2 = [25, 36, 49, 64] new_squares = squares1 + squares2 print(new_squares) . &gt;&gt;&gt; [1, 4, 9, 16, 25, 36, 49, 64] . 리스트는 정수 곱셈 연산을 지원한다. 리스트 내의 항목들을 정수 만큼 반복하여 새로운 리스트를 만들어낸다. fruits = ['Apple', 'Pear', 'Banana'] new_fruits = fruits * 3 print(new_fruits) . &gt;&gt;&gt; ['Apple', 'Pear', 'Banana', 'Apple', 'Pear', 'Banana', 'Apple', 'Pear', 'Banana'] . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#리스트의-산술-연산"
  },"71": {
    "doc": "리스트",
    "title": "리스트 내 항목 변경",
    "content": "불변 시퀀스형인 문자열과 다르게, 리스트는 가변mutable 시퀀스형이므로 내용 변경이 가능하다. 다음은 가, 나, 다 순서의 글자를 갖는 리스트 hangeul_letters 의 2 번 인덱스가 잘못되어 해당 항목을 변경하는 예제 코드이다. hangeul_letters = ['가', '나', '아', '라', '마', '바'] hangeul_letters[2] = '다' print(hangeul_letters) . &gt;&gt;&gt; ['가', '나', '다', '라', '마', '바'] . 슬라이스에 대한 할당도 가능하며, 이를 통해 리스트의 일부 값을 변경할 수 있다. 이번 예제는 다음 내용을 수행한다. | 2, 3 번 인덱스의 값 변경 | 4 번 부터 끝 인덱스 항목 제거 | . a = ['a', 'b', 'C', 'D', 'e', 'f'] a[2:4] = 'c', 'd' a[4:] = [] print(a) . &gt;&gt;&gt; ['a', 'b', 'c', 'd'] . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EB%82%B4-%ED%95%AD%EB%AA%A9-%EB%B3%80%EA%B2%BD",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#리스트-내-항목-변경"
  },"72": {
    "doc": "리스트",
    "title": "리스트 항목 개수",
    "content": "리스트 항목 개수는 내장 함수 len 을 사용하여 확인할 수 있다. numbers = [1, 2, 3, 4, 5] print(len(numbers)) . &gt;&gt;&gt; 5 . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#%EB%A6%AC%EC%8A%A4%ED%8A%B8-%ED%95%AD%EB%AA%A9-%EA%B0%9C%EC%88%98",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#리스트-항목-개수"
  },"73": {
    "doc": "리스트",
    "title": "리스트 중첩nesting",
    "content": "리스트안의 항목으로 리스트를 포함할 수 있다. a = [1, 2, 3] b = [4, 5, 6] c = [a, b] print(c) print(c[0]) print(c[1]) print(c[1][2]) . [[1, 2, 3], [4, 5, 6]] [1, 2, 3] [4, 5, 6] 6 . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%A4%91%EC%B2%A9nesting",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#리스트-중첩nesting"
  },"74": {
    "doc": "리스트",
    "title": "리스트 복사하기",
    "content": "아래와 같이 변수 a 리스트를 b 에 할당하면 b 또한 a 가 참조하는 객체를 가리키게 된다. 단순 할당은 데이터를 복사하지 않고, 기존 객체를 참조하게 되기 때문이다. a = [1, 2, 3] b = a print(a is b) . True . 만약 a 의 항목을 변경하게 되면, b 가 참조하는 객체가 a 와 같으므로 b 가 갖는 값도 변경되게 된다. a = [1, 2, 3] b = a a[2] = 100 print(b) . &gt;&gt;&gt; [1, 2, 100] . a 가 참조하는 리스트를 복사(항목은 그대로 가져오고, 리스트는 새로 생성)하는 두 가지 방법에 대해 알아본다. 다음에 소개할 예제처럼 복사하는 것을 얕은 복사shallow copy라고 한다. 얕은 복사는 리스트 내부의 값들은 그대로 참조하지만, 리스트 자체를 새로운 객체로 생성한다. 예제 - copy 함수를 사용하여 리스트 복사 . 파이썬 내장 모듈 copy 의 copy 함수를 사용하면 항목은 그대로 가져오면서 리스트는 새로 생성하게 된다. import copy a = [1, 2, 3] b = copy.copy(a) a[2] = 100 print(b) . &gt;&gt;&gt; [1, 2, 3] . 앞서 얘기한 것 처럼 슬라이싱은 새로운 리스트를 반환한다. 슬라이스의 범위를 전체로 하게되면 복사를 할 수 있다. a = [1, 2, 3] b = a[:] a[2] = 100 print(b) . &gt;&gt;&gt; [1, 2, 3] . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EB%B3%B5%EC%82%AC%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#리스트-복사하기"
  },"75": {
    "doc": "리스트",
    "title": "리스트 관련 메서드",
    "content": "리스트에서 제공되는 몇 가지 중요한 메서드를 간단히 알아본다. 메서드에 대한 자세한 내용과 추가적인 것 들에 대해서는 자료 구조data structure에서 다룰 예정이다. append - 리스트 끝에 항목을 추가 . numbers = [1, 2, 3, 4] numbers.append(5) print(numbers) . &gt;&gt;&gt; [1, 2, 3, 4, 5] . extend - 리스트 끝에 항목을 추가 . append 메서드는 객체를 항목에 그대로 추가하는 반면, extend 메서드는 반복 가능한 객체의 각 요소를 개별 항목으로 추가한다. 반복 가능한 객체는 반복문으로 한 번에 하나씩 요소를 차례대로 꺼낼 수 있는 개체를 말한다. 먼저 append 를 사용했을 때와 extend 를 사용했을 때의 차이점을 보자. append 메서드를 사용한 경우 . numbers1 = [1, 2, 3] numbers2 = [4, 5, 6] numbers1.append(numbers2) print(numbers1) . &gt;&gt;&gt; [1, 2, 3, [4, 5, 6]] . extend 메서드를 사용한 경우 . numbers1 = [1, 2, 3] numbers2 = [4, 5, 6] numbers1.extend(numbers2) print(numbers1) . &gt;&gt;&gt; [1, 2, 3, 4, 5, 6] . 문자열도 반복 가능한 객체로, extend 메서드의 인수로 사용할 수 있다. alphabet_letters = ['a', 'b', 'c', 'd', 'e'] alphabet_letters.extend('fghijk') print(alphabet_letters) . &gt;&gt;&gt; ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'] . insert - 특정 인덱스에 항목을 추가 . insert 메서드는 특정 인덱스에 항목을 추가하는 기능을 한다. 기존에 있던 값은 인덱스가 하나 밀리게 된다. insert 는 첫 번째 매개변수로 인덱스 번호를 받고, 두 번째 매개변수는 항목으로 추가할 객체를 받는다. days = ['월', '화', '목', '금'] print('변경 전 days[2]:', days[2]) print('변경 전 days[3]:', days[3]) days.insert(2, '수') print('\\n변경 후 days[2]:', days[2]) print('변경 후 days[3]:', days[3]) print('\\ndays:', days) . &gt;&gt;&gt; 변경 전 days[2]: 목 변경 전 days[3]: 금 변경 후 days[2]: 수 변경 후 days[3]: 목 days: ['월', '화', '수', '목', '금'] . remove - 특정 값을 갖는 항목 삭제하기 . 리스트 내 특정 값을 갖는 항목을 삭제하려면 remove 메서드를 사용한다. remove 메서드는 리스트는 다음과 같이 동작한다. | 리스트 내에서 remove 메서드에 사용된 인수와 일치하는 항목 확인 | 리스트에서 해당 항목 제거 | . 일치하는 항목이 여러개이면 가장 낮은 인덱스에 위치한 항목만 제거됨에 유의해야한다. days = ['월', '화', '수', '목', '목', '금', '토', '일'] days.remove('목') print(days) . &gt;&gt;&gt; ['월', '화', '수', '목', '금', '토', '일'] . 항목의 인덱스를 알고 있을 때 해당 항목을 제거하려면 파이썬 내장 키워드인 del 을 사용할 수 있다. days = ['월', '화', '수', '목', '목', '금', '토', '일'] del days[3] print(days) . &gt;&gt;&gt; ['월', '화', '수', '목', '금', '토', '일'] . count - 특정 값을 갖는 항목의 개수 . numbers = [1, 2, 2, 3, 3, 3] print(numbers.count(2)) . &gt;&gt;&gt; 2 . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EA%B4%80%EB%A0%A8-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#리스트-관련-메서드"
  },"76": {
    "doc": "리스트",
    "title": "연습 문제",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#%EC%97%B0%EC%8A%B5-%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%A6%AC%EC%8A%A4%ED%8A%B8.html#연습-문제"
  },"77": {
    "doc": "문자열",
    "title": "문자열 (String)",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#%EB%AC%B8%EC%9E%90%EC%97%B4-string",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#문자열-string"
  },"78": {
    "doc": "문자열",
    "title": "개요",
    "content": "문자열은 문자들이 순서대로 연결되어 있는 시퀀스 자료형이며, 한번 생성되면 내부의 개별 문자를 변경할 수 없는 특징을 가진다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#개요"
  },"79": {
    "doc": "문자열",
    "title": "문자열의 표현",
    "content": "작은 따옴표 또는 큰 따옴표 안에 작성된 데이터는 문자열로 취급한다. 리터럴은 데이터를 표현하는 방식을 말하며, 따옴표로 표현된 문자열을 문자열 리터럴 이라고 한다. 예제 - 문자열의 표현 . string0 = '작은 따옴표 사용' string1 = \"큰 따옴표 사용\" print(string0) print(string1) print(\"작은 따옴표 사용(Type):\", type(string0)) print(\"큰 따옴표 사용(Type):\", type(string1)) . &gt;&gt;&gt; 작은 따옴표 사용 큰 따옴표 사용 작은 따옴표 사용(Type): &lt;class 'str'&gt; 큰 따옴표 사용(Type): &lt;class 'str'&gt; . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%98-%ED%91%9C%ED%98%84",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#문자열의-표현"
  },"80": {
    "doc": "문자열",
    "title": "문자열의 길이",
    "content": "문자열의 길이는 len 함수로 확인 가능하다. nba_player = \"LeBron Raymone James Sr.\" print(len(nba_player)) . &gt;&gt;&gt; 24 . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%98-%EA%B8%B8%EC%9D%B4",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#문자열의-길이"
  },"81": {
    "doc": "문자열",
    "title": "문자열에 특정 문자열이 포함되어 있는지 확인",
    "content": "in 연산자로 문자열에 특정 문자열이 있는지 확인할 수 있다. robert = \"10. 피할수 없으면 즐겨라 – 로버트 엘리엇\" print(\"로버트\" in robert) print(\"헬렌켈러\" in robert) . True False . 위 예제에서 not in 연산자를 사용하면 결과가 반대로 나온다. robert = \"10. 피할수 없으면 즐겨라 – 로버트 엘리엇\" print(\"로버트\" not in robert) print(\"헬렌켈러\" not in robert) . False True . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#%EB%AC%B8%EC%9E%90%EC%97%B4%EC%97%90-%ED%8A%B9%EC%A0%95-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%B4-%ED%8F%AC%ED%95%A8%EB%90%98%EC%96%B4-%EC%9E%88%EB%8A%94%EC%A7%80-%ED%99%95%EC%9D%B8",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#문자열에-특정-문자열이-포함되어-있는지-확인"
  },"82": {
    "doc": "문자열",
    "title": "원시 문자열 (Raw String)",
    "content": "문자열에 백슬래쉬(\\\\)와 같은 특수한 문자를 포함할 때는 이스케이프 시퀀스를 사용해야 한다. 이 것과 관련하여 문자열 입력받기 에서 정리한 바 있다. Windows 에서는 폴더 경로 구분자로 백슬래쉬(\\) 를 사용하므로 이스케이프 시퀀스를 이용해 문자열로 표현하면 가독성이 매우 떨어질 수 있다. 예를 들어 \"C:\\\\Users\\\\user\\\\Documents\\\\Onedrive\\\\문서\\\\002.Work\\\\IT\\\\redhat 문의\" 와 같이 작성해야 한다. 이런 경우 문자열 리터럴 앞에 r 을 붙이면 이스케이프 시퀀스를 무시하고 그대로 표현할 수 있고 가독성 또한 개선된다. 이렇게 문자열 리터럴 앞에 r 을 붙인 것을 원시 문자열(Raw String)이라고 부른다. 예제 - 원시 문자열 . print(\"C:\\\\Users\\\\user\\\\Documents\\\\Onedrive\\\\문서\\\\002.Work\\\\IT\\\\redhat 문의\") print(r\"C:\\Users\\user\\Documents\\Onedrive\\문서\\002.Work\\IT\\redhat 문의\") . &gt;&gt;&gt; C:\\Users\\user\\Documents\\Onedrive\\문서\\002.Work\\IT\\redhat 문의 C:\\Users\\user\\Documents\\Onedrive\\문서\\002.Work\\IT\\redhat 문의 . 원시 문자열은 백슬래쉬와 그 뒤에 나오는 문자를 이스케이프 시퀀스로 처리하지 않고, 그대로 표현한다. 따라서 문자열 마지막에 백슬래쉬(\\)를 사용하면 종료 따옴표와 충돌하여 문법 에러가 발생함에 유의해야 한다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#%EC%9B%90%EC%8B%9C-%EB%AC%B8%EC%9E%90%EC%97%B4-raw-string",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#원시-문자열-raw-string"
  },"83": {
    "doc": "문자열",
    "title": "문자열은 대소문자를 구분한다",
    "content": "파이썬의 문자열은 기본적으로 유니코드를 사용하며, 유니코드에서는 영문 대문자, 소문자마다 서로 다른 코드를 부여한다. 따라서 파이썬에서도 문자열의 대소문자를 구분하여 처리한다. 예제 - 유니 코드 . print(\"a\" == \"A\") print(\"a 의 유니코드:\", hex(ord(\"a\"))) print(\"A 의 유니코드:\", hex(ord(\"A\"))) . &gt;&gt;&gt; False a 의 유니코드: 0x61 A 의 유니코드: 0x41 . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%80-%EB%8C%80%EC%86%8C%EB%AC%B8%EC%9E%90%EB%A5%BC-%EA%B5%AC%EB%B6%84%ED%95%9C%EB%8B%A4",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#문자열은-대소문자를-구분한다"
  },"84": {
    "doc": "문자열",
    "title": "여러줄 출력하기",
    "content": "애국가 가사를 예시로 print 함수 내에서 여러줄을 출력하는 다양한 방법에 대해서 알아본다. 다음 예제들의 결과는 모두 같다. 동해물과 백두산이 마르고 닳도록 하느님이 보우하사 우리나라 만세 무궁화 삼천리 화려강산 대한사람 대한으로 길이 보전하세 . 예제 - 한 줄에 모두 작성 . print(\"동해물과 백두산이 마르고 닳도록\\n하느님이 보우하사 우리나라 만세\\n무궁화 삼천리 화려강산\\n대한사람 대한으로 길이 보전하세\") . 예제 - 삼중 따옴표를 사용하여 여러 줄에 작성 . print(\"\"\" 동해물과 백두산이 마르고 닳도록 하느님이 보우하사 우리나라 만세 무궁화 삼천리 화려강산 대한사람 대한으로 길이 보전하세 \"\"\") . 예제 - 인접한 문자열 리터럴을 사용하여 여러 줄에 작성 . print( \"동해물과 백두산이 마르고 닳도록\\n\" \"하느님이 보우하사 우리나라 만세\\n\" \"무궁화 삼천리 화려강산\\n\" \"대한사람 대한으로 길이 보전하세\" ) . 인접한 문자열 리터럴을 변수 할당에 사용할 때는 소괄호((, ))로 감싸서 작성하면 된다. korean_national_anthem = ( \"동해물과 백두산이 마르고 닳도록\\n\" \"하느님이 보우하사 우리나라 만세\\n\" \"무궁화 삼천리 화려강산\\n\" \"대한사람 대한으로 길이 보전하세\" ) print(korean_national_anthem) . 인접한 문자열 리터럴끼리의 연결은 가능하지만, 변수나 표현식과 함께 사용할 수는 없다. 다음은 변수와 문자열 리터럴을 연결시키려고 시도할 때의 결과이다. lyrics = \"동해물과 \" print( lyrics \"백두산이\" ) . \"백두산이\" ^^^^^^ SyntaxError: invalid syntax . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#%EC%97%AC%EB%9F%AC%EC%A4%84-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#여러줄-출력하기"
  },"85": {
    "doc": "문자열",
    "title": "문자열 리터럴에 변수를 포함시키기",
    "content": "파이썬에서 문자열에 변수나 표현식을 포함시키는 방법은 세가지가 있다. % 연산자, str.format() 메소드, f-string 가 있으며 f-string 은 % 연산자나 str.format() 연산자에 비해 비교적 최근에 나온 기능으로 최신 파이썬에서 권장되는 방식이다. f-string 은 f 로 시작하는 문자열 리터럴로 중괄호({}) 안에 변수나 표현식을 직접 작성하면 해당 값이 문자열에 삽입되도록 한다. f-string 리터럴 내부에서 중괄호를 사용하려면 중첩({{ 또는 }})하여 사용하면 된다. 변수) name = '방승호' city = '서울' age = 34 ... 결과) 안녕하세요. 저는 서울에 사는 34 살 방승호입니다. 아래 예제들은 위 박스의 공통 변수를 갖고 같은 결과를 출력한다. 예제 - 문자열 리터럴에 변수를 포함시키기 . print(\"안녕하세요.\\n저는 %s에 사는 %d살 %s입니다.\" % (city, age, name)) print(\"안녕하세요.\\n저는 {}에 사는 {}살 {}입니다.\".format(city, age, name)) print(f\"안녕하세요.\\n저는 {city}에 사는 {age}살 {name}입니다.\") # f-string 사용 . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4%EC%97%90-%EB%B3%80%EC%88%98%EB%A5%BC-%ED%8F%AC%ED%95%A8%EC%8B%9C%ED%82%A4%EA%B8%B0",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#문자열-리터럴에-변수를-포함시키기"
  },"86": {
    "doc": "문자열",
    "title": "f-string 의 유용한 기능들",
    "content": "다음은 f-string 이 제공하는 몇 가지 유용한 기능에 대한 예제이다. 예제 - 날짜 포매팅 . import datetime current_date = datetime.datetime.now() print(f'{current_date:%B %d, %Y}') . &gt;&gt;&gt; February 23, 2025 . 예제 - 표현식 사용 . current_year = 2025 print(f'작년은 {current_year - 1}년 이고, 내년은 {current_year + 1}년 이다.') . 예제 - 폭 조정 . name = '방승호' city = '서울' hobby = '유튜브 감상' header = f\"{'이름':^10}{'주거 지역':^10}{'취미':^10}\" header_line = '=' * 40 contents = f\"{name:^10}{city:^10}{hobby:^10}\" print(header) print(header_line) print(contents) . &gt;&gt;&gt; 이름 주거 지역 취미 ======================================== 방승호 서울 유튜브 감상 . 예제 - 숫자 앞에 패딩 넣기 . file_number = 9 print(f'{file_number:03}') file_number += 1 print(f'{file_number:03}') . &gt;&gt;&gt; 009 010 . 예제 - 반올림 . some_number = 3.1 ** 3.1 print(some_number) print(f\"{some_number:.2f}\") . &gt;&gt;&gt; 33.35963197890903 33.36 . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#f-string-%EC%9D%98-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EA%B8%B0%EB%8A%A5%EB%93%A4",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#f-string-의-유용한-기능들"
  },"87": {
    "doc": "문자열",
    "title": "문자열에서 특정 문자에 가져오기",
    "content": "문자열에서 각 문자들은 순서대로 번호가 부여되며, 그 번호를 인덱스(index) 라고 부른다. 인덱스는 특별한 경우가 아니면 0 부터 시작하는게 일반적이며, 문자열 또한 인덱스는 0 부터 시작한다. 인덱스를 사용하여 객체의 요소를 가져오는 방법을 subscripting 이라고 한다. 예제 - 특정 문자 가져오기 . 문자열 Python 에서 두번째 문자, 즉 y 에 접근하는 예제이다. print(\"Python\"[1]) . &gt;&gt;&gt; y . 음수 인덱스는 -1 부터 시작하고 문자열 끝에서부터 역순으로 번호가 매겨진다. print(\"Python\"[-1]) print(\"Python\"[-2]) . &gt;&gt;&gt; n o . 인덱스 범위 밖의 인덱스를 사용하면 IndexError 가 발생한다. print(\"Python\"[6]) . &gt;&gt;&gt; Traceback (most recent call last): File \"h:\\pytest\\test.py\", line 1, in &lt;module&gt; print(\"Python\"[6]) ~~~~~~~~^^^ IndexError: string index out of range . 또한 빈 문자열에 인덱스 접근 시에도 IndexError 가 발생한다. &gt;&gt;&gt; \"\"[0] . Traceback (most recent call last): File \"h:\\pytest\\test.py\", line 1, in &lt;module&gt; print(\"\"[0]) ~~^^^ IndexError: string index out of range . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#%EB%AC%B8%EC%9E%90%EC%97%B4%EC%97%90%EC%84%9C-%ED%8A%B9%EC%A0%95-%EB%AC%B8%EC%9E%90%EC%97%90-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#문자열에서-특정-문자에-가져오기"
  },"88": {
    "doc": "문자열",
    "title": "문자열 슬라이스",
    "content": "문자열의 일부분을 잘라내어 새로운 문자열을 만들 수 있는데, 이를 슬라이싱이라고 한다. 슬라이싱을 사용하면 문자열에서 특정 범위의 문자들을 쉽게 추출할 수 있다. 슬라이스는 문자열[start:end] 형태로 사용하며 끝 인덱스 포함되지 않는다. 예제 - 문자열 슬라이싱 . 아래는 인덱스 2 부터 4 까지 슬라이싱하는 예제이다. 슬라이싱에서 끝 인덱스(아래 예제에서 : 의 오른쪽)는 포함하지 않는다. print(\"Python\"[0:2]) print(\"Python\"[2:4]) print(\"Python\"[4:6]) . &gt;&gt;&gt; Py th on . 슬라이싱에서 첫 인덱스, 끝 인덱스는 생략 가능하다. print(\"Python\"[:3]) print(\"Python\"[3:]) . &gt;&gt;&gt; Pyt hon . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EC%8A%A4",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#문자열-슬라이스"
  },"89": {
    "doc": "문자열",
    "title": "문자열은 변경이 불가능하다.",
    "content": "문자열은 불변immutable 시퀀스 타입으로 요소 변경이 불가능하다. 다음 코드와 같이 요소를 변경하려고 하는 경우 에러가 발생한다. apple = \"apPle\" apple[2] = \"p\" print(apple) . Traceback (most recent call last): File \"h:\\pytest\\test.py\", line 2, in &lt;module&gt; apple[2] = \"p\" ~~~~~^^^ TypeError: 'str' object does not support item assignment . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%80-%EB%B3%80%EA%B2%BD%EC%9D%B4-%EB%B6%88%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#문자열은-변경이-불가능하다"
  },"90": {
    "doc": "문자열",
    "title": "문자열 관련 메서드",
    "content": "유용한 문자열 관련 메서드 몇 가지를 알아본다. lstrip - 왼쪽 공백 제거 . star = \"★\" letter_o = ' O' print(\"lstrip 전:\", star + letter_o) print(\"lstrip 후:\", star + letter_o.lstrip()) . &gt;&gt;&gt; lstrip 전: ★ O lstrip 후: ★O . rstrip - 오른쪽 공백 제거 . star = \"★\" letter_o = 'O ' print(\"rstrip 전:\", letter_o + star) print(\"rstrip 후:\", letter_o.rstrip() + star) . &gt;&gt;&gt; rstrip 전: O ★ rstrip 후: O★ . strip - 양쪽 공백 제거 . star = \"★\" letter_o = ' o o o o o ' print(\"strip 전:\", star + letter_o + star) print(\"strip 후:\", star + letter_o.strip() + star) . &gt;&gt;&gt; strip 전: ★ o o o o o ★ strip 후: ★o o o o o★ . title - 단어의 첫 문자를 대문자로 변환 . title 메서드는 단어의 첫 문자를 대문자로, 나머지 문자들을 소문자로 변환시킨다. english_name = \"seungho bAng\".title() print(english_name) . &gt;&gt;&gt; Seungho Bang . lower - 모든 문자를 소문자로 변환 . word = 'LOWER' print(word.lower()) . &gt;&gt;&gt; lower . upper - 모든 문자를 대문자로 변환 . word = 'upper' print(word.upper()) . &gt;&gt;&gt; UPPER . 특정 문자 치환 (replace) . alphabet = \"A\\nB\\nC\\nD\\nE\" print(alphabet.replace('\\n', '')) . &gt;&gt;&gt; ABCDE . 시작 문자열이 일치하는지 검사 (startswith) . cpu = \"CPU Usage: 58%\" memory = \"Memory Usage: 32%\" print(cpu.startswith('CPU Usage')) print(memory.startswith('CPU Usage')) . &gt;&gt;&gt; True False . 끝 문자열이 일치하는지 검사 (endswith) . config_file = \"config.json\" page_file = \"index.html\" print(config_file.endswith(\".json\")) print(page_file.endswith(\".json\")) . &gt;&gt;&gt; True False . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B4%80%EB%A0%A8-%EB%A9%94%EC%84%9C%EB%93%9C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#문자열-관련-메서드"
  },"91": {
    "doc": "문자열",
    "title": "연습문제",
    "content": "연습문제1 . python_study = \" pythoN studY \" 변수 python_study 의 출력 결과가 \"PythonStduy\" 가 되도록 바꾸어 보세요. 연습문제2 . apple = \"apPlE\" 문자열 슬라이싱을 사용해서 변수 apple 의 결과가 APPLE 이 되도록 코드를 작성해 보세요. 연습문제3 . pi = 3.14159265359 f-string 을 사용하여 변수 pi 의 출력 결과가 3.142 가 나오도록 코드를 작성해 보세요. 연습문제4 . PEP8 스타일 가이드에 따르면 코드 한줄의 길이를 79 자로 제한합니다. 다음에 제시되는 코드 한 줄의 길이가 PEP8 스타일 가이드에 적합한지 확인해 보세요. lyrics_of_old_song = \"That long black cloud is comin' down.\\nI feel I'm knockin' on Heaven's door.\" . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#연습문제"
  },"92": {
    "doc": "문자열",
    "title": "추가 자료",
    "content": "f-strings . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#%EC%B6%94%EA%B0%80-%EC%9E%90%EB%A3%8C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html#추가-자료"
  },"93": {
    "doc": "문자열",
    "title": "문자열",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%AC%B8%EC%9E%90%EC%97%B4.html"
  },"94": {
    "doc": "문자열 입력받기",
    "title": "문자열 입력받기",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%9E%85%EB%A0%A5%EB%B0%9B%EA%B8%B0.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%9E%85%EB%A0%A5%EB%B0%9B%EA%B8%B0.html"
  },"95": {
    "doc": "문자열 입력받기",
    "title": "Input 함수 사용해보기",
    "content": "input(\"이름을 입력해주세요: \") . &gt;&gt;&gt; 이름을 입력해주세요: 방승호 . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%9E%85%EB%A0%A5%EB%B0%9B%EA%B8%B0.html#input-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%9E%85%EB%A0%A5%EB%B0%9B%EA%B8%B0.html#input-함수-사용해보기"
  },"96": {
    "doc": "문자열 입력받기",
    "title": "입력받은 문자열 합쳐서 출력하기",
    "content": "print(\"저의 이름은 \" + input(\"이름을 입력해주세요: \") + \"입니다.\") . &gt;&gt;&gt; 이름을 입력해주세요: 방승호 저의 이름은 방승호입니다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%9E%85%EB%A0%A5%EB%B0%9B%EA%B8%B0.html#%EC%9E%85%EB%A0%A5%EB%B0%9B%EC%9D%80-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%95%A9%EC%B3%90%EC%84%9C-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%9E%85%EB%A0%A5%EB%B0%9B%EA%B8%B0.html#입력받은-문자열-합쳐서-출력하기"
  },"97": {
    "doc": "문자열 입력받기",
    "title": "문자열에서 탭 / 개행 / 작은따옴표 / 큰따옴표 / 백슬래쉬 사용하기 (Escape sequences)",
    "content": "문자열 안에서 이스케이프 코드로 탭, 개행, 작은따옴표, 큰따옴표, 백슬래쉬를 사용할 수 있다. 이스케이프 시퀀스는 \\ (백슬래쉬) 로 시작하며 아래 예시 코드와 같이 동작한다. # 탭 (\\t) print(\"이스케이프 시퀀스 탭\\t예제 입니다.\") # 개행 (\\n) print(\"이스케이프 시퀀스\\n개행\\n예제 입니다.\") # 작은 따옴표 (') print(\"이스케이프 시퀀스 \\'작은 따옴표\\' 예제 입니다.\") # 큰 따옴표 (\") print(\"이스케이프 시퀀스 \\\"큰 따옴표\\\" 예제 입니다.\") # 백슬래쉬 print(\"이스케이프 시퀀스 \\\\백슬래쉬\\\\ 예제 입니다.\") . 이스케이프 시퀀스 탭 예제 입니다. 이스케이프 시퀀스 개행 예제 입니다. 이스케이프 시퀀스 '작은 따옴표' 예제 입니다. 이스케이프 시퀀스 \"큰 따옴표\" 예제 입니다. 이스케이프 시퀀스 \\백슬래쉬\\ 예제 입니다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%9E%85%EB%A0%A5%EB%B0%9B%EA%B8%B0.html#%EB%AC%B8%EC%9E%90%EC%97%B4%EC%97%90%EC%84%9C-%ED%83%AD--%EA%B0%9C%ED%96%89--%EC%9E%91%EC%9D%80%EB%94%B0%EC%98%B4%ED%91%9C--%ED%81%B0%EB%94%B0%EC%98%B4%ED%91%9C--%EB%B0%B1%EC%8A%AC%EB%9E%98%EC%89%AC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-escape-sequences",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%9E%85%EB%A0%A5%EB%B0%9B%EA%B8%B0.html#문자열에서-탭--개행--작은따옴표--큰따옴표--백슬래쉬-사용하기-escape-sequences"
  },"98": {
    "doc": "문자열 입력받기",
    "title": "추가 자료",
    "content": ". | Escape sequences | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%9E%85%EB%A0%A5%EB%B0%9B%EA%B8%B0.html#%EC%B6%94%EA%B0%80-%EC%9E%90%EB%A3%8C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%9E%85%EB%A0%A5%EB%B0%9B%EA%B8%B0.html#추가-자료"
  },"99": {
    "doc": "문자열 출력하기",
    "title": "문자열 출력하기",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0.html"
  },"100": {
    "doc": "문자열 출력하기",
    "title": "CMD",
    "content": ". | python 프로그램 실행 | print 함수 호출 | 실행 결과 | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0.html#cmd",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0.html#cmd"
  },"101": {
    "doc": "문자열 출력하기",
    "title": "IDLE",
    "content": ". | Windows -&gt; IDLE 검색 -&gt; IDLE (Python …) 실행 | 이 후 CMD [2] 부터와 같음 | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0.html#idle",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0.html#idle"
  },"102": {
    "doc": "문자열 출력하기",
    "title": "Pycharm (IDE)",
    "content": "New Project 클릭 New Project &gt; Pure Python Location 마지막 경로를 ds_python_study 로 변경 후 Create 좌측 네비게이션에 있는 ds_python_study 우클릭 &gt; New &gt; Directory Directory 명을 001_Basic_Input_Output 으로 생성 좌측 네비게이션에 있는 001_Basic_Input_Output 우클릭 &gt; New &gt; File 파일명을 001_문자열_출력하기.py 로 생성 위 캡쳐 처럼 코드 작성 후 ▷ 를 클릭하여 코드 실행 프로그램 하단 터미널에서 코드 실행 결과가 출력된다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0.html#pycharm-ide",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0.html#pycharm-ide"
  },"103": {
    "doc": "문자열 출력하기",
    "title": "기본 함수 사용방법",
    "content": "함수는 특정 작업을 수행하기 위한 코드 모음이다. 함수 이름 뒤에 () 괄호를 붙여 함수를 호출할 수 있다. 함수이름() . () 괄호 안에는 함수 매개변수에 따라 인자를 넣거나 생략할 수 있다. 예를 들어 print 함수의 경우 () 괄호를 비우는 경우 개행이 되고, 인자를 넣으면 print 함수에 의해 처리되어 콘솔 화면에 출력된다. print(\"문장1\") print() print(\"문장2\") . &gt;&gt;&gt; 문장1 문장2 . Pycharm 의 경우 함수의 () 괄호안에 커서를 두고 Ctrl + q 를 입력하면 함수에 대한 도움말(매개변수, 타입 힌트, docstring 등)을 볼 수 있다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0.html#%EA%B8%B0%EB%B3%B8-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EB%AC%B8%EC%9E%90%EC%97%B4_%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0.html#기본-함수-사용방법"
  },"104": {
    "doc": "변수 정의하기",
    "title": "변수 정의하기",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%B3%80%EC%88%98_%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%B3%80%EC%88%98_%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0.html"
  },"105": {
    "doc": "변수 정의하기",
    "title": "개요",
    "content": "파이썬에서 변수는 값(객체)에 대한 참조 역할을 한다. 변수는 사용하기 전에 미리 어떤 값을 참조할지 정의해야 한다. 예제 - 변수 정의하기 . tomato = \"토마토\" tomato_brix = \"8\" banana = \"바나나\" banana_brix = \"23\" print(tomato + \"의 당도는 평균 \" + tomato_brix + \" brix 입니다.\") print(banana + \"의 당도는 평균 \" + banana_brix + \" brix 입니다.\") . &gt;&gt;&gt; 토마토의 당도는 평균 8 brix 입니다. 바나나의 당도는 평균 23 brix 입니다. 예제 - 한 줄에 여러 변수 정의하기 . 아래 예제는 한 줄에 여러 개의 변수를 정의하는 방법을 보여주며, 이를 언패킹(unpacking)이라고 한다. small_number, large_number = 1, 1_000_000_000 print(\"small_number:\", small_number) print(\"large_number:\", large_number) . &gt;&gt;&gt; small_number: 1 large_number: 1000000000 . 예제 - 정의되지 않은 변수 . 정의되지 않은 변수를 사용하면 NameError가 발생한다. print(my_variable) . &gt;&gt;&gt; Traceback (most recent call last): File \"d:\\pytest.py\", line 1, in &lt;module&gt; print(my_variable) ^^^^^^^^^^^ NameError: name 'my_variable' is not defined . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%B3%80%EC%88%98_%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0.html#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%B3%80%EC%88%98_%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0.html#개요"
  },"106": {
    "doc": "변수 정의하기",
    "title": "변수 이름 짓기",
    "content": "변수 이름 짓기에는 몇 가지 규칙이 있으며, 위반 시 에러가 발생한다. 문법 규칙 . | 영문, 숫자, 밑줄(_)만 사용하며 숫자로 시작하면 안된다. | 변수 이름 사이에 공백이 있으면 안된다. | 파이썬 내장 (built-in) 키워드는 사용할 수 없다. | 대소문자를 구분한다. | . 아래는 변수 이름 관련 규칙 위반 시 발생하는 에러에 대한 몇가지 예제이다. 예제 - 변수 이름 첫 번째 문자가 숫자인 경우 . 0var = 1 . &gt;&gt;&gt; File \"C:\\Users\\ME\\PycharmProjects\\ds_python_study\\003_Variables\\001_변수.py\", line 1 0var = 1 ^ SyntaxError: invalid decimal literal . 예제 - 변수 이름에 특수문자를 사용한 경우 . variable&gt; = 123 . &gt;&gt;&gt; File \"d:\\pytest.py\", line 1 variable&gt; = 123 ^ SyntaxError: invalid syntax . 예제 - 변수 이름을 파이썬 키워드를 사용한 경우 . class = \"High\" . &gt;&gt;&gt; File \"C:\\Users\\ME\\PycharmProjects\\ds_python_study\\003_Variables\\001_변수.py\", line 1 class = High ^ SyntaxError: invalid syntax . 권고 사항 . | 파이썬 내장 변수, 함수, 클래스, 모듈 등은 가급적 사용하면 안된다. | _ 하나로 끝나는 변수는 변수 이름 충돌을 피하기 위해 사용한다. | 변수 이름은 소문자를 사용하고 공백 등 구분이 필요한 경우 _ 를 사용한다. (snake case) | 간결하면서 의미를 알 수 있게 짓는 것이 좋다. un 보다는 username 또는 user_name 이 낫다. | 상수는 모두 대문자로 표기한다. RED = 1 GREEN = 2 BLUE = 3 ORANGE = 4 . | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%B3%80%EC%88%98_%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0.html#%EB%B3%80%EC%88%98-%EC%9D%B4%EB%A6%84-%EC%A7%93%EA%B8%B0",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%B3%80%EC%88%98_%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0.html#변수-이름-짓기"
  },"107": {
    "doc": "변수 정의하기",
    "title": "연습 문제",
    "content": "연습 문제1 - 변수 교환하기 . a = 3 b = 5 두 변수 a, b 가 참조하는 값을 교환하시오. 연습 문제2 - 자기 소개 하기 . 이름, 사는 곳, 취미를 입력받아 출력하는 프로그램을 만들어 보시오. 예시) 이름: 방승호 사는 곳: 서울 취미: 유튜브 감상 안녕하세요. 제 이름은 방승호입니다. 서울에 살고 있고, 취미는 유튜브 감상입니다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%B3%80%EC%88%98_%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0.html#%EC%97%B0%EC%8A%B5-%EB%AC%B8%EC%A0%9C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%B3%80%EC%88%98_%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0.html#연습-문제"
  },"108": {
    "doc": "변수 정의하기",
    "title": "추가 자료",
    "content": ". | PEP8 - 작명 컨벤션 (번역) | 변수는 객체에 대한 참조이다 | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%B3%80%EC%88%98_%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0.html#%EC%B6%94%EA%B0%80-%EC%9E%90%EB%A3%8C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%B3%80%EC%88%98_%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0.html#추가-자료"
  },"109": {
    "doc": "변수는 객체에 대한 참조이다",
    "title": "변수는 객체에 대한 참조이다",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EA%B3%A0%EA%B8%89_%ED%8C%81/%EB%B3%80%EC%88%98%EB%8A%94_%EA%B0%9D%EC%B2%B4%EC%97%90_%EB%8C%80%ED%95%9C_%EC%B0%B8%EC%A1%B0%EC%9D%B4%EB%8B%A4.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EA%B3%A0%EA%B8%89_%ED%8C%81/%EB%B3%80%EC%88%98%EB%8A%94_%EA%B0%9D%EC%B2%B4%EC%97%90_%EB%8C%80%ED%95%9C_%EC%B0%B8%EC%A1%B0%EC%9D%B4%EB%8B%A4.html"
  },"110": {
    "doc": "변수는 객체에 대한 참조이다",
    "title": "변수는 박스가 아니다",
    "content": "파이썬 교육 자료들을 보면 종종 변수를 박스에 비유하는 경우를 볼 수 있다. | 변수는 값을 저장하는 공간이다. | 변수를 값을 담는 박스로 생각하면 변수에 대해 이해하기 쉽다. | . 하지만 아래 예제를 통해 이 비유가 적절하지 않음을 확인할 수 있다. &gt;&gt;&gt; a = [1, 2, 3, 4] &gt;&gt;&gt; b = a &gt;&gt;&gt; a[0] = 5 &gt;&gt;&gt; b [5, 2, 3, 4] . 값을 담는 박스에 비유하여 해석하면 다음과 같다. | a: 저장 공간에 리스트 [1, 2, 3, 4] 를 할당한다. | b=a: a 의 값을 b 저장 공간에 할당한다. (값 복사) | a[0] = 5:: 변수 a 의 0 번 인덱스의 값을 기존 1 에서 5 로 교체한다. | b: b 의 0 번 인덱스가 왜 바뀌었지? | . 파이썬에서 변수의 역할은 객체에 대한 참조이기 때문에 박스 비유는 배우는 입장에서 혼란을 야기한다. b = a 는 값 복사가 아닌 a 가 참조하고 있는 객체를 b 도 참조하겠다는 의미로 해석해야 한다. 올바른 해석은 다음과 같다. | a: 리스트 [1, 2, 3, 4] 를 생성하고 변수 a 에 바인딩한다. | b=a: 변수 a 가 참조하는 객체를 변수 b 에 바인딩한다. | a[0] = 5: 변수 a 가 참조하는 리스트의 첫 번째 요소 값을 1 에서 5 로 변경한다. | b: a 와 b 가 같은 객체를 참조하고 있으므로, a 가 참조하는 값을 변경하면, b 도 영향을 받는다. | . 또한, 파이썬 할당문은 할당식(=)의 오른쪽에서 객체를 먼저 생성한 뒤 왼쪽의 변수에 바인딩한다. 즉, 변수가 먼저 생성된 뒤 값을 할당받는다는 것이 아니라는 의미이다. 다음은 REPL 환경에서 변수가 먼저 생성되지 않음을 증명하는 예제이다. &gt;&gt;&gt; a = 3.5 &gt;&gt;&gt; b = 3.5 * \"hello\" Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; TypeError: can't multiply sequence by non-int of type 'float' &gt;&gt;&gt; dir() ['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'a'] . 변수 a 는 정상적으로 생성되었지만, b 는 할당문의 오른쪽 식에서 에러가 발생했으므로 생성되지 않았다. 일부 언어에서는 실제 메모리 공간(즉, 박스)을 미리 할당한 후 그 공간에 값을 저장하기 때문에 박스 비유가 적절할 수 있지만, 파이썬에서는 변수는 객체의 참조를 저장한다는 점에 유의해야 한다. 변수를 박스에 비유하는 것보다 올바른 비유는 박스에 붙은 라벨이라고 표현하는 것이다. 라벨은 단지 박스에 붙은 이름이므로 동일한 박스에 여러 라벨을 붙일 수도 있다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EA%B3%A0%EA%B8%89_%ED%8C%81/%EB%B3%80%EC%88%98%EB%8A%94_%EA%B0%9D%EC%B2%B4%EC%97%90_%EB%8C%80%ED%95%9C_%EC%B0%B8%EC%A1%B0%EC%9D%B4%EB%8B%A4.html#%EB%B3%80%EC%88%98%EB%8A%94-%EB%B0%95%EC%8A%A4%EA%B0%80-%EC%95%84%EB%8B%88%EB%8B%A4",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EA%B3%A0%EA%B8%89_%ED%8C%81/%EB%B3%80%EC%88%98%EB%8A%94_%EA%B0%9D%EC%B2%B4%EC%97%90_%EB%8C%80%ED%95%9C_%EC%B0%B8%EC%A1%B0%EC%9D%B4%EB%8B%A4.html#변수는-박스가-아니다"
  },"111": {
    "doc": "변수와 자료형",
    "title": "변수와 자료형",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95.html"
  },"112": {
    "doc": "빌더 패턴",
    "title": "빌더 패턴The builder pattern",
    "content": "여러 부분으로 구성되어 있으며, 그 구성 과정이 단계별로 진행되어야 하는 객체를 생성한다고 상상해보자. 모든 부품이 완전히 생성되지 않으면 객체는 완성되지 않는다. 이때 빌더 디자인패턴이 유용하다. 빌더 패턴은 복잡한 객체의 생성 과정construction process을 그 객체의 표현representation과 분리한다. 즉, 생성 과정과 표현을 분리함으로써 동일한 생성 절차를 통해 여러 가지 다른 표현의 객체를 만들 수 있게 된다. 이 시점에서 빌더 패턴과 팩토리 패턴의 차이가 다소 모호해 보일 수 있다. 주요 차이점은 팩토리 패턴은 객체를 한 번에 생성하는 반면, 빌더 패턴은 객체를 여러 단계에 걸쳐 생성하며 거의 항상 디렉터를 사용한다는 것이다. 또 다른 차이점은 팩토리 패턴은 생성된 객체를 즉시 반환하지만, 빌더 패턴에서는 클라이언트 코드가 필요할 때 디렉터에게 최종 객체를 명시적으로 요청한다는 점이다. 빌더 패턴은 객체를 다양한 구성 옵션으로 생성해야 할 때 특히 유용하다. 예를 들어 한 클래스에 매개변수의 수가 다른 여러 생성자가 있을 경우, 코드가 혼란스러워지고 오류가 발생하기 쉬운데 이를 방지할 수 있다. 또한, 객체 생성 과정이 단순히 초기 값을 설정하는 것 이상의 복잡한 절차(예: 매개변수 검증, 데이터 구조 설정, 외부 서비스 호출 등)를 포함할 때 빌더 패턴은 이러한 복잡성을 캡슐화하는 데 큰 도움이 된다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EB%B9%8C%EB%8D%94_%ED%8C%A8%ED%84%B4.html#%EB%B9%8C%EB%8D%94-%ED%8C%A8%ED%84%B4the-builder-pattern",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EB%B9%8C%EB%8D%94_%ED%8C%A8%ED%84%B4.html#빌더-패턴the-builder-pattern"
  },"113": {
    "doc": "빌더 패턴",
    "title": "빌더 패턴 구현",
    "content": "빌더 디자인 패턴을 활용하여 피자 주문 애플리케이션을 구현하는 방법을 보여준다. 피자는 도우, 소스, 토핑 추가, 굽기 등 여러 단계에 걸쳐 준비되어야 하는 복잡한 객체이다. 예를 들어, 소스를 추가하기 전에 도우를 준비해야 하고, 토핑을 추가하기 전에는 소스를 넣어야 하며, 도우에 소스와 토핑이 모두 올려지기 전까지는 굽기를 시작할 수 없다. 또한, 각 피자는 도우의 두께와 토핑에 따라 굽는 시간이 달라질 수 있다. import time from enum import Enum PizzaProgress = Enum(\"PizzaProgress\", \"queued preparation baking ready\") PizzaDough = Enum(\"PizaaDough\", \"thin thick\") PizzaSauce = Enum(\"PizzaSauce\", \"tomato creme_fraiche\") PizzaTopping = Enum( \"PizzaTopping\", \"mozzarella double_mozzarella bacon ham mushrooms red_onion oregano\", ) # Delay in seconds STEP_DELAY = 3 class Pizza: def __init__(self, name): self.name = name self.dough = None self.sauce = None self.toppings = [] def __str__(self): return self.name def prepare_dough(self, dough): self.dough = dough print(f\"preparing the {self.dough.name} dough of your {self}...\") time.sleep(STEP_DELAY) print(f\"done with the {self.dough.name} dough\") class MargaritaBuilder: def __init__(self): self.pizza = Pizza(\"margarita\") self.progress = PizzaProgress.queued self.baking_time = 5 def prepare_dough(self): self.progress = PizzaProgress.preparation self.pizza.prepare_dough(PizzaDough.thin) def add_sauce(self): print(\"adding the tomato sauce to your margarita...\") self.pizza.sauce = PizzaSauce.tomato time.sleep(STEP_DELAY) print(\"done with the tomato sauce\") def add_topping(self): topping_desc = \"double mozzarella, oregano\" topping_items = ( PizzaTopping.double_mozzarella, PizzaTopping.oregano ) print(f\"adding the topping ({topping_desc} to your margarita)\") self.pizza.toppings.append([t for t in topping_items]) time.sleep(STEP_DELAY) print(f\"done with the topping ({topping_desc}\") def bake(self): self.progress = PizzaProgress.baking print(f\"baking your margarita for {self.baking_time} seconds\") time.sleep(self.baking_time) self.progress = PizzaProgress.ready print(\"your margarita is ready\") class CreamyBaconBuilder: def __init__(self): self.pizza = Pizza(\"creamy bacon\") self.progress = PizzaProgress.queued self.baking_time = 7 def prepare_dough(self): self.progress = PizzaProgress.preparation self.pizza.prepare_dough(PizzaDough.thick) def add_sauce(self): print(\"adding the creme fraiche sauce to your creamy bacon\") self.pizza.sauce = PizzaSauce.creme_fraiche time.sleep(STEP_DELAY) print(\"done with the creme fraiche sauce\") def add_topping(self): topping_desc = \"mozzarella, bacon, ham, mushrooms, red onion, oregano\" topping_items = ( PizzaTopping.mozzarella, PizzaTopping.bacon, PizzaTopping.ham, PizzaTopping.mushrooms, PizzaTopping.red_onion, PizzaTopping.oregano ) print(f\"adding the topping ({topping_desc}) to your creamy bacon\") self.pizza.toppings.append([t for t in topping_items]) time.sleep(STEP_DELAY) print(f\"done with the topping ({topping_desc}\") def bake(self): self.progress = PizzaProgress.baking print(f\"baking your creamy bacon for {self.baking_time} seconds\") time.sleep(self.baking_time) self.progress = PizzaProgress.ready print(\"your creamy bacon is ready\") class Waiter: def __init__(self): self.builder = None def construct_pizza(self, builder): self.builder = builder steps = ( builder.prepare_dough, builder.add_sauce, builder.add_topping, builder.bake ) [step() for step in steps] @property def pizza(self): return self.builder.pizza def validate_style(builders): try: input_msg = \"What pizza would you like, [m]argarita or [c]reamy bacon?\" pizza_style = input(input_msg).lower() builder = builders[pizza_style]() except KeyError: error_msg = \"Sorry, only margarita and creamy bacon are available\" print(error_msg) return (False, None) return (True, builder) def main(): builders = dict(m=MargaritaBuilder, c=CreamyBaconBuilder) valid_input = False builder = None while not valid_input: valid_input, builder = validate_style(builders) print() waiter = Waiter() waiter.construct_pizza(builder) pizza = waiter.pizza print() print(f\"Enjoy your {pizza}\") if __name__ == \"__main__\": main() . What pizza would you like, [m]argarita or [c]reamy bacon?c preparing the thick dough of your creamy bacon... done with the thick dough adding the creme fraiche sauce to your creamy bacon done with the creme fraiche sauce adding the topping (mozzarella, bacon, ham, mushrooms, red onion, oregano) to your creamy bacon done with the topping (mozzarella, bacon, ham, mushrooms, red onion, oregano baking your creamy bacon for 7 seconds your creamy bacon is ready Enjoy your creamy bacon . &gt;&gt;&gt; What pizza would you like, [m]argarita or [c]reamy bacon?m preparing the thin dough of your margarita... done with the thin dough adding the tomato sauce to your margarita... done with the tomato sauce adding the topping (double mozzarella, oregano to your margarita) done with the topping (double mozzarella, oregano baking your margarita for 5 seconds your margarita is ready Enjoy your margarita . | 필요한 모듈 임포트 및 상수 정의 . import time from enum import Enum PizzaProgress = Enum(\"PizzaProgress\", \"queued preparation baking ready\") PizzaDough = Enum(\"PizaaDough\", \"thin thick\") PizzaSauce = Enum(\"PizzaSauce\", \"tomato creme_fraiche\") PizzaTopping = Enum( \"PizzaTopping\", \"mozzarella double_mozzarella bacon ham mushrooms red_onion oregano\", ) # Delay in seconds STEP_DELAY = 3 . time 모듈과 Enum 클래스를 임포트하고, PizzaProgress, PizzaDough, PizzaSauce, PizzaTopping 등의 열거형을 선언했다. STEP_DELAY 상수로 각 단계 사이의 지연 시간을 설정한다. | Pizza 클래스 정의 . class Pizza: def __init__(self, name): self.name = name self.dough = None self.sauce = None self.toppings = [] def __str__(self): return self.name def prepare_dough(self, dough): self.dough = dough print(f\"preparing the {self.dough.name} dough of your {self}...\") time.sleep(STEP_DELAY) print(f\"done with the {self.dough.name} dough\") . 피자 객체의 최종 제품을 나타내며, 도우, 소스, 토핑 정보를 초기화한다. prepare_dough 메서드는 도우 준비 과정을 수행하며, 실제 빌더에서 호출되는 도우 준비 메서드를 간접적으로 사용한다. | 빌더 클래스(MargaritaBuilder, CreamyBaconBuilder) 정의 . class MargaritaBuilder: def __init__(self): self.pizza = Pizza(\"margarita\") self.progress = PizzaProgress.queued self.baking_time = 5 def prepare_dough(self): self.progress = PizzaProgress.preparation self.pizza.prepare_dough(PizzaDough.thin) def add_sauce(self): print(\"adding the tomato sauce to your margarita...\") self.pizza.sauce = PizzaSauce.tomato time.sleep(STEP_DELAY) print(\"done with the tomato sauce\") def add_topping(self): topping_desc = \"double mozzarella, oregano\" topping_items = ( PizzaTopping.double_mozzarella, PizzaTopping.oregano ) print(f\"adding the topping ({topping_desc} to your margarita)\") self.pizza.toppings.append([t for t in topping_items]) time.sleep(STEP_DELAY) print(f\"done with the topping ({topping_desc}\") def bake(self): self.progress = PizzaProgress.baking print(f\"baking your margarita for {self.baking_time} seconds\") time.sleep(self.baking_time) self.progress = PizzaProgress.ready print(\"your margarita is ready\") class CreamyBaconBuilder: def __init__(self): self.pizza = Pizza(\"creamy bacon\") self.progress = PizzaProgress.queued self.baking_time = 7 def prepare_dough(self): self.progress = PizzaProgress.preparation self.pizza.prepare_dough(PizzaDough.thick) def add_sauce(self): print(\"adding the creme fraiche sauce to your creamy bacon\") self.pizza.sauce = PizzaSauce.creme_fraiche time.sleep(STEP_DELAY) print(\"done with the creme fraiche sauce\") def add_topping(self): topping_desc = \"mozzarella, bacon, ham, mushrooms, red onion, oregano\" topping_items = ( PizzaTopping.mozzarella, PizzaTopping.bacon, PizzaTopping.ham, PizzaTopping.mushrooms, PizzaTopping.red_onion, PizzaTopping.oregano ) print(f\"adding the topping ({topping_desc}) to your creamy bacon\") self.pizza.toppings.append([t for t in topping_items]) time.sleep(STEP_DELAY) print(f\"done with the topping ({topping_desc}\") def bake(self): self.progress = PizzaProgress.baking print(f\"baking your creamy bacon for {self.baking_time} seconds\") time.sleep(self.baking_time) self.progress = PizzaProgress.ready print(\"your creamy bacon is ready\") . 각 빌더 클래스는 자신만의 피자 타입을 생성한다. 빌더 클래스는 prepare_dough, add_sauce, add_topping, bake 등 의 메서드를 구현하여 피자 준비의 각 단계를 처리한다. 각 빌더는 자신에게 맞는 도우 종료, 소스 토핑, 굽는 시간 등의 피자 관련 세부사항을 정의한다. | 디렉터 클래스(Waiter) 정의 . class Waiter: def __init__(self): self.builder = None def construct_pizza(self, builder): self.builder = builder steps = ( builder.prepare_dough, builder.add_sauce, builder.add_topping, builder.bake ) [step() for step in steps] @property def pizza(self): return self.builder.pizza . Waiter 클래스는 생성 과정을 조욜하는 역할로, construct_pizza 메서드를 통해 전달받은 빌더의 단계별 메서드를 올바른 순서로 호출한다. 최종적으로 완성된 피자는 pizza 속성을 통해 외부로 제공된다. | validate_style 함수와 main 함수 . def validate_style(builders): try: input_msg = \"What pizza would you like, [m]argarita or [c]reamy bacon?\" pizza_style = input(input_msg).lower() builder = builders[pizza_style]() except KeyError: error_msg = \"Sorry, only margarita and creamy bacon are available\" print(error_msg) return (False, None) return (True, builder) def main(): builders = dict(m=MargaritaBuilder, c=CreamyBaconBuilder) valid_input = False builder = None while not valid_input: valid_input, builder = validate_style(builders) print() waiter = Waiter() waiter.construct_pizza(builder) pizza = waiter.pizza print() print(f\"Enjoy your {pizza}\") . validate_style 함수는 사용자 입력을 받아 올바른 빌더를 선택하고, 잘못된 입력에 대해 오류 메시지를 출력한다. main 함수에서는 사용자로부터 피자 타입 선택을 받고, 해당 빌더를 이용해 Waiter 가 피자를 준비하도록 한다. | . 마지막으로 에제는 두 가지 피자 타입만 지원하지만, 상속이나 구성을 통해 새로운 피자 타입을 쉽게 확장할 수 있다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EB%B9%8C%EB%8D%94_%ED%8C%A8%ED%84%B4.html#%EB%B9%8C%EB%8D%94-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%84",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EB%B9%8C%EB%8D%94_%ED%8C%A8%ED%84%B4.html#빌더-패턴-구현"
  },"114": {
    "doc": "빌더 패턴",
    "title": "추가 자료",
    "content": ". | django-query-builder | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EB%B9%8C%EB%8D%94_%ED%8C%A8%ED%84%B4.html#%EC%B6%94%EA%B0%80-%EC%9E%90%EB%A3%8C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EB%B9%8C%EB%8D%94_%ED%8C%A8%ED%84%B4.html#추가-자료"
  },"115": {
    "doc": "빌더 패턴",
    "title": "빌더 패턴",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EB%B9%8C%EB%8D%94_%ED%8C%A8%ED%84%B4.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EB%B9%8C%EB%8D%94_%ED%8C%A8%ED%84%B4.html"
  },"116": {
    "doc": "생성 디자인 패턴",
    "title": "생성 디자인 패턴",
    "content": "생성 디자인 패턴은 Gang of Four 디자인 패턴에서 다룰 첫 번째 범주이다. 이 패턴들은 객체 생성의 다양한 측면을 다루며, Python 에서 init 메소드 내에서 직접 객체를 생성하는 것이 불편한 상황에 대해 더 나은 대안을 제공하는 것을 목표로 한다. 다음의 주요 주제들을 다룰 것이다. | 팩토리 패턴The factory pattern | 빌더 패턴The builder pattern | 프로토타입 패턴The prototype pattern | 싱글턴 패턴The singleton pattern | 오브젝트 풀 패턴The object pool pattern | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4.html"
  },"117": {
    "doc": "연산자 우선순위",
    "title": "연산자 우선순위 (Operator precedence)",
    "content": "| Operator | Description | . | \\(expressions...\\),\\[expressions...\\],{key: value...},{expressions...} | Binding or parenthesized expression, list display, dictionary display, set display | . | x[index], x[index:index], x(arguments...), x.attribute | Subscription, slicing, call, attribute reference | . | await x | Await expression | . | ** | Exponentiation | . | +x, -x, ~x | Positive, negative, bitwise NOT | . | *, @, /, //, % | Multiplication, matrix multiplication, division, floor division, remainder | . | +, - | Addition and subtraction | . | &lt;&lt;, &gt;&gt; | Shifts | . | &amp; | Bitwise AND | . | ^ | Bitwise XOR | . | | Bitwise OR | . | in, not in, is, is not, &lt;, &lt;=, &gt;, &gt;=, !=, == | Comparisons, including membership tests and identity tests | . | not x | Boolean NOT | . | and | Boolean AND | . | or | Boolean OR | . | if – else | Conditional expression | . | lambda | Lambda expression | . | := | Assignment expression | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%97%B0%EC%82%B0%EC%9E%90_%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84.html#%EC%97%B0%EC%82%B0%EC%9E%90-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-operator-precedence",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%97%B0%EC%82%B0%EC%9E%90_%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84.html#연산자-우선순위-operator-precedence"
  },"118": {
    "doc": "연산자 우선순위",
    "title": "추가 자료",
    "content": ". | Operator precedence | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%97%B0%EC%82%B0%EC%9E%90_%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84.html#%EC%B6%94%EA%B0%80-%EC%9E%90%EB%A3%8C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%97%B0%EC%82%B0%EC%9E%90_%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84.html#추가-자료"
  },"119": {
    "doc": "연산자 우선순위",
    "title": "연산자 우선순위",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%97%B0%EC%82%B0%EC%9E%90_%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%97%B0%EC%82%B0%EC%9E%90_%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84.html"
  },"120": {
    "doc": "유용한 사이트",
    "title": "유용한 사이트",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9C%A0%EC%9A%A9%ED%95%9C_%EC%82%AC%EC%9D%B4%ED%8A%B8.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9C%A0%EC%9A%A9%ED%95%9C_%EC%82%AC%EC%9D%B4%ED%8A%B8.html"
  },"121": {
    "doc": "유용한 사이트",
    "title": "Table of Contents",
    "content": ". | 유용한 사이트 . | Table of Contents | 파이썬 공식 홈페이지 | 웹북 | Question | AI | Education | 기타 | . | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9C%A0%EC%9A%A9%ED%95%9C_%EC%82%AC%EC%9D%B4%ED%8A%B8.html#table-of-contents",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9C%A0%EC%9A%A9%ED%95%9C_%EC%82%AC%EC%9D%B4%ED%8A%B8.html#table-of-contents"
  },"122": {
    "doc": "유용한 사이트",
    "title": "파이썬 공식 홈페이지",
    "content": ". | The Python Standard Library | Python Tutorial | PEP8 - Style Guide for Python Code | Python Download | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9C%A0%EC%9A%A9%ED%95%9C_%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B3%B5%EC%8B%9D-%ED%99%88%ED%8E%98%EC%9D%B4%EC%A7%80",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9C%A0%EC%9A%A9%ED%95%9C_%EC%82%AC%EC%9D%B4%ED%8A%B8.html#파이썬-공식-홈페이지"
  },"123": {
    "doc": "유용한 사이트",
    "title": "웹북",
    "content": ". | 초보자를 위한 파이썬 300제 | 점프 투 파이썬 | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9C%A0%EC%9A%A9%ED%95%9C_%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%EC%9B%B9%EB%B6%81",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9C%A0%EC%9A%A9%ED%95%9C_%EC%82%AC%EC%9D%B4%ED%8A%B8.html#웹북"
  },"124": {
    "doc": "유용한 사이트",
    "title": "Question",
    "content": ". | Stack Overflow | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9C%A0%EC%9A%A9%ED%95%9C_%EC%82%AC%EC%9D%B4%ED%8A%B8.html#question",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9C%A0%EC%9A%A9%ED%95%9C_%EC%82%AC%EC%9D%B4%ED%8A%B8.html#question"
  },"125": {
    "doc": "유용한 사이트",
    "title": "AI",
    "content": ". | deepseek | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9C%A0%EC%9A%A9%ED%95%9C_%EC%82%AC%EC%9D%B4%ED%8A%B8.html#ai",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9C%A0%EC%9A%A9%ED%95%9C_%EC%82%AC%EC%9D%B4%ED%8A%B8.html#ai"
  },"126": {
    "doc": "유용한 사이트",
    "title": "Education",
    "content": ". | reeborg - 로봇 게임 | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9C%A0%EC%9A%A9%ED%95%9C_%EC%82%AC%EC%9D%B4%ED%8A%B8.html#education",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9C%A0%EC%9A%A9%ED%95%9C_%EC%82%AC%EC%9D%B4%ED%8A%B8.html#education"
  },"127": {
    "doc": "유용한 사이트",
    "title": "기타",
    "content": ". | OS 별 명령어 모음 | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9C%A0%EC%9A%A9%ED%95%9C_%EC%82%AC%EC%9D%B4%ED%8A%B8.html#%EA%B8%B0%ED%83%80",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9C%A0%EC%9A%A9%ED%95%9C_%EC%82%AC%EC%9D%B4%ED%8A%B8.html#기타"
  },"128": {
    "doc": "이스케이프 시퀀스",
    "title": "이스케이프 시퀀스",
    "content": "| Escape Sequence | Meaning | . | \\&lt;newline&gt; | Backslash and newline ignored | . | \\\\ | Backslash (\\) | . | \\' | Single quote (') | . | \\\" | Double quote (\") | . | \\a | ASCII Bell (BEL) | . | \\b | ASCII Backspace (BS) | . | \\f | ASCII Formfeed (FF) | . | \\n | ASCII Linefeed (LF) | . | \\r | ASCII Carriage Return (CR) | . | \\t | ASCII Horizontal Tab (TAB) | . | \\v | ASCII Vertical Tab (VT) | . | \\ooo | Character with octal value ooo | . | \\xhh | Character with hex value hh | . Escape sequences only recognized in string literals are: . | Escape Sequence | Meaning | . | \\N{name} | Character named name in the Unicode database | . | \\uxxxx | Character with 16-bit hex value xxxx | . | \\Uxxxxxxxx | Character with 32-bit hex value xxxxxxxx | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9D%B4%EC%8A%A4%EC%BC%80%EC%9D%B4%ED%94%84_%EC%8B%9C%ED%80%80%EC%8A%A4.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%9D%B4%EC%8A%A4%EC%BC%80%EC%9D%B4%ED%94%84_%EC%8B%9C%ED%80%80%EC%8A%A4.html"
  },"129": {
    "doc": "입력과 출력",
    "title": "입력과 출력",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5/%EC%9E%85%EB%A0%A5%EA%B3%BC_%EC%B6%9C%EB%A0%A5.html"
  },"130": {
    "doc": "자료형",
    "title": "자료형",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EC%9E%90%EB%A3%8C%ED%98%95.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EC%9E%90%EB%A3%8C%ED%98%95.html"
  },"131": {
    "doc": "자료형",
    "title": "개요",
    "content": "자료형(Data Type)은 프로그래밍 언어에서 데이터를 저장하고 처리하는 방식과 형태를 정의하는 분류 기준이다. 각 자료형은 데이터가 어떻게 표현되고 연산될지를 결정하는 역할을 한다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EC%9E%90%EB%A3%8C%ED%98%95.html#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EC%9E%90%EB%A3%8C%ED%98%95.html#개요"
  },"132": {
    "doc": "자료형",
    "title": "자료형 확인",
    "content": "객체가 어떤 자료형인지 확인하려면 type 함수를 사용하면 된다. 아래 예제 코드는 정수형(integer), 부동소수점(floating_point), 문자열(string), 리스트(list) 형을 출력한다. 예제 - 자료형 확인 . integer = 5 floating_point = 5.0 string = \"Hello\" list_ = [1, 2, 3, 4] print(\"integer = 5\") print(type(integer)) print(\"\\nfloating_point = 5.0\") print(type(floating_point)) print('\\nstring = \"Hello\"') print(type(string)) print('\\nlist_ = [1, 2, 3, 4]') print(type(list_)) . &gt;&gt;&gt; integer = 5 &lt;class 'int'&gt; floating_point = 5.0 &lt;class 'float'&gt; string = \"Hello\" &lt;class 'str'&gt;** list_ = [1, 2, 3, 4] &lt;class 'list'&gt; . 위에 소개한 자료형들은 파이썬 내장 자료형으로, 파이썬 프로그래밍의 기초가 되는 자료형들이다. 변수와 자료형 항목에서는 기본 자료형인 숫자형과 문자열, 리스트에 대해서 간략하게 알아볼 예정이다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EC%9E%90%EB%A3%8C%ED%98%95.html#%EC%9E%90%EB%A3%8C%ED%98%95-%ED%99%95%EC%9D%B8",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EB%B3%80%EC%88%98%EC%99%80_%EC%9E%90%EB%A3%8C%ED%98%95/%EC%9E%90%EB%A3%8C%ED%98%95.html#자료형-확인"
  },"133": {
    "doc": "장고 시작하기",
    "title": "장고 시작하기",
    "content": " ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EC%9E%A5%EA%B3%A0_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0.html",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EC%9E%A5%EA%B3%A0_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0.html"
  },"134": {
    "doc": "장고 시작하기",
    "title": "venv 환경 세팅",
    "content": "&gt; python -m venv ./Django-for-Begginers &gt; ./Django-for-Begginers/Scripts/activate.ps1 . ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EC%9E%A5%EA%B3%A0_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0.html#venv-%ED%99%98%EA%B2%BD-%EC%84%B8%ED%8C%85",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EC%9E%A5%EA%B3%A0_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0.html#venv-환경-세팅"
  },"135": {
    "doc": "장고 시작하기",
    "title": "django 패키지 설치",
    "content": "&gt; pip install django~=5.0.0 Collecting django~=5.0.0 Obtaining dependency information for django~=5.0.0 from https://files.pythonhosted.org/packages/00/5b/cadc834acdcafeacf7fc7d4a9e21a7009d2e677ae2e5d0d640845ed0a356/Django-5.0.12-py3-none-any.whl.metadata Downloading Django-5.0.12-py3-none-any.whl.metadata (4.1 kB) Collecting asgiref&lt;4,&gt;=3.7.0 (from django~=5.0.0) Obtaining dependency information for asgiref&lt;4,&gt;=3.7.0 from https://files.pythonhosted.org/packages/39/e3/893e8757be2612e6c266d9bb58ad2e3651524b5b40cf56761e985a28b13e/asgiref-3.8.1-py3-none-any.whl.metadata Downloading asgiref-3.8.1-py3-none-any.whl.metadata (9.3 kB) Collecting sqlparse&gt;=0.3.1 (from django~=5.0.0) Obtaining dependency information for sqlparse&gt;=0.3.1 from https://files.pythonhosted.org/packages/a9/5c/bfd6bd0bf979426d405cc6e71eceb8701b148b16c21d2dc3c261efc61c7b/sqlparse-0.5.3-py3-none-any.whl.metadata Downloading sqlparse-0.5.3-py3-none-any.whl.metadata (3.9 kB) Collecting tzdata (from django~=5.0.0) Obtaining dependency information for tzdata from https://files.pythonhosted.org/packages/0f/dd/84f10e23edd882c6f968c21c2434fe67bd4a528967067515feca9e611e5e/tzdata-2025.1-py2.py3-none-any.whl.metadata Using cached tzdata-2025.1-py2.py3-none-any.whl.metadata (1.4 kB) Downloading Django-5.0.12-py3-none-any.whl (8.2 MB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 8.2/8.2 MB 20.9 MB/s eta 0:00:00 Downloading asgiref-3.8.1-py3-none-any.whl (23 kB) Downloading sqlparse-0.5.3-py3-none-any.whl (44 kB) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 44.4/44.4 kB ? eta 0:00:00 Using cached tzdata-2025.1-py2.py3-none-any.whl (346 kB) Installing collected packages: tzdata, sqlparse, asgiref, django Successfully installed asgiref-3.8.1 django-5.0.12 sqlparse-0.5.3 tzdata-2025.1 [notice] A new release of pip is available: 23.2.1 -&gt; 25.0.1 [notice] To update, run: python.exe -m pip install --upgrade pip . ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EC%9E%A5%EA%B3%A0_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0.html#django-%ED%8C%A8%ED%82%A4%EC%A7%80-%EC%84%A4%EC%B9%98",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EC%9E%A5%EA%B3%A0_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0.html#django-패키지-설치"
  },"136": {
    "doc": "장고 시작하기",
    "title": "django 프로젝트 설치",
    "content": "&gt; django-admin startproject django_project . 다음과 같은 구조의 파일과 디렉토리가 생성된다. &gt; tree /f /a | manage.py | \\---django_project asgi.py settings.py urls.py wsgi.py __init__.py . ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EC%9E%A5%EA%B3%A0_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0.html#django-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%84%A4%EC%B9%98",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EC%9E%A5%EA%B3%A0_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0.html#django-프로젝트-설치"
  },"137": {
    "doc": "장고 시작하기",
    "title": "django 실행하기",
    "content": "&gt; python manage.py runserver Watching for file changes with StatReloader Performing system checks... System check identified no issues (0 silenced). You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions. Run 'python manage.py migrate' to apply them. March 01, 2025 - 21:57:29 Django version 5.0.12, using settings 'django_project.settings' Starting development server at http://127.0.0.1:8000/ Quit the server with CTRL-BREAK. &gt; dir Mode LastWriteTime Length Name ---- ------------- ------ ---- d----- 2025-03-01 오후 9:57 django_project -a---- 2025-03-01 오후 9:57 0 db.sqlite3 -a---- 2025-03-01 오후 9:56 692 manage.py . | 서버 실행 이 후 db.sqlite3 파일이 새로 생성됐다. SQLite 는 연결 시 해당 파일이 없으면 자동으로 새 파일을 만든다. | http://127.0.0.1:8000 대신 http://localhost:8000 으로도 접속 가능하다. | Ctrl + c 키를 눌러 로컬 서버를 중지할 수 있다. | . ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EC%9E%A5%EA%B3%A0_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0.html#django-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EC%9E%A5%EA%B3%A0_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0.html#django-실행하기"
  },"138": {
    "doc": "제어 흐름",
    "title": "제어 흐름",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84.html"
  },"139": {
    "doc": "제어 흐름 사전지식",
    "title": "제어 흐름 사전지식",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84_%EC%82%AC%EC%A0%84%EC%A7%80%EC%8B%9D.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84_%EC%82%AC%EC%A0%84%EC%A7%80%EC%8B%9D.html"
  },"140": {
    "doc": "제어 흐름 사전지식",
    "title": "식expressions과 문statements",
    "content": "식은 값으로 평가될 수 있는 코드 조각이다. 값으로 평가되는지는 eval 함수를 사용하여 확인할 수 있다. eval 함수는 문자열 인자를 받으며, 식을 계산한 뒤 값을 반환한다. 만약 식이 아닌 경우 SyntaxError 를 발생시킨다. eval(\"print(5 + 3)\") . &gt;&gt;&gt; 8 . 할당문assignment statement은 식이 아니므로 eval 로 처리할 수 없다. eval(\"x = 5 + 3\") . &gt;&gt;&gt; Traceback (most recent call last): File \"...\", line 1, in &lt;module&gt; eval(\"x = 5 + 3\") File \"&lt;string&gt;\", line 1 x = 5 + 3 ^ SyntaxError: invalid syntax . 문은 프로그램이 실행할 수 있는 한 줄 또는 한 개의 명령어를 의미한다. 문인지 확인하는 방법은 exec 함수를 사용하면 된다. eval 과 마찬가지로 문자열을 인자로 받는다. exec 함수는 입력받은 문을 실행하며 반환되는 값은 없다. exec(\"x = 5 + 3\") print(x) . &gt;&gt;&gt; 8 . 식 또한 문의 일부이다. exec(\"print(5 + 3)\") . &gt;&gt;&gt; 8 . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84_%EC%82%AC%EC%A0%84%EC%A7%80%EC%8B%9D.html#%EC%8B%9Dexpressions%EA%B3%BC-%EB%AC%B8statements",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84_%EC%82%AC%EC%A0%84%EC%A7%80%EC%8B%9D.html#식expressions과-문statements"
  },"141": {
    "doc": "제어 흐름 사전지식",
    "title": "BNF 표기법에 대한 이해",
    "content": "The Python Language Reference 에 작성되어 있는 어휘 분석lexical analysis와 구문syntax를 이해하기 위해서 BNFBackust-Naur Form 표기법을 이해할 필요가 있다. 이 표기법은 다음과 같은 정의 스타일을 따른다. | 각 규칙은 규칙에 의해 정의된 이름과 ::= 로 시작한다. | 수직 바는 | 선택지를 구분하는 데 사용되며, 이 표기법에서 가장 낮은 결합력을 갖는다. | *는 바로 앞의 항목이 0 회 이상 반복됨을 의미한다. | +는 바로 앞의 항목이 1 회 이상 반복됨을 의미한다. | []안에 있는 구분은 0 회 또는 1회 발생(즉, 선택사항)을 나타낸다. | 리터럴 문자열은 따옴표\"\"로 둘러 싸인다. | 공백은 토큰을 구분하기 위해서만 의미를 가지며, 규칙은 보통 한 줄에 작성되지만 선택지가 많은 경우 첫 번째 줄 이후 각 줄이 수직 막대(|)로 시작할 수 있다. | . 어휘 정의에서는 두 가지 추가 규칙이 사용된다. | 범위 지정: 두 개의 리터럴 문자가 세 개의 점(\"a\"...\"z\")으로 구분된 경우, 주어진 ASCII 문자 범위 내의 임의의 단일 문자를 의미한다. | 비공식적 설명: 꺾쇠 괄호(&lt;...&gt;)안의 구문은 정의된 기호symbol에 대한 비공식적 설명을 제공한다. 예를 들어, 필요에 따라 제어 문자control character라는 개념을 설명할 때 사용할 수 있다. | . name ::= lc_letter (lc_letter | \"_\")* lc_letter ::= \"a\"...\"z\" . 위의 예시는 첫 번째 줄 name 이 하나의 소문자(lc_letter)로 시작하고, 그 뒤에 소문자나 밑줄_이 0 회 이상 반복되는 패턴임을 나타낸다. 여기서 lc_letter 는 ‘a’ 부터 ‘z’ 까지의 단일 문자 중 하나를 의미한다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84_%EC%82%AC%EC%A0%84%EC%A7%80%EC%8B%9D.html#bnf-%ED%91%9C%EA%B8%B0%EB%B2%95%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84_%EC%82%AC%EC%A0%84%EC%A7%80%EC%8B%9D.html#bnf-표기법에-대한-이해"
  },"142": {
    "doc": "제어 흐름 사전지식",
    "title": "복합문Compound statements",
    "content": "복합문은 다른 문장들(또는 문장들의 그룹)을 포함하며, 이들 문장의 실행을 제어하거나 영향을 준다. 보통 복합문은 여러 줄에 걸쳐 작성되지만, 간단한 경우에는 전체 복합문이 한 줄에 포함될 수 있다. 복합문은 하나 이상의 절clause로 구성되며, 각 절은 헤더header와 슈트suite로 이루어진다. | 절 헤더: 같은 복합문 내의 모든 절 헤더는 동일한 들여쓰기 수준indentation level을 가지며, 고유한 키워드로 시작해 콜론:으로 끝난다. | 슈트: 절에 의해 제어되는 문장들의 그룹이다. 슈트는 헤더 뒤에 같은 줄에 세미콜론(;)으로 구분된 단순문들로 나타날 수 있고, 다음 줄부터 들여쓰기된 여러개의 문장으로 나타날 수 있다. 단, 들여쓰기된 슈트만이 중첩된 복합문을 포함할 수 있다. | . 참고로 들여쓰기는 4칸 공백 또는 탭을 사용하는데, 플랫폼간 일관성을 위해 일반적으로 4칸 공백이 선호된다. 대부분 IDE 에서 tab 은 공백 4칸으로 자동 변환된다. BNF 로 표기한 문법은 다음과 같다. compound_stmt ::= if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | match_stmt | funcdef | classdef | async_with_stmt | async_for_stmt | async_funcdef suite ::= stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT statement ::= stmt_list NEWLINE | compound_stmt stmt_list ::= simple_stmt (\";\" simple_stmt)* [\";\"] . | compound_stmt: 복합문으로 사용할 수 있는 여러 종류의 문을 나타낸다. | stmt_list: 한 줄에 작성된 하나 이상의 단순문simple statement들을 나타낸다. | statement: 하나의 실행 단위가 되는 문장을 의미한다. | suite: 복합문에서 실행될 여러 문장의 블록을 의미한다. | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84_%EC%82%AC%EC%A0%84%EC%A7%80%EC%8B%9D.html#%EB%B3%B5%ED%95%A9%EB%AC%B8compound-statements",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84_%EC%82%AC%EC%A0%84%EC%A7%80%EC%8B%9D.html#복합문compound-statements"
  },"143": {
    "doc": "조건문",
    "title": "조건문Conditional statements",
    "content": "조건문은 식의 참 거짓을 판별하여 코드 실행 여부를 결정한다. 이번 섹션에서는 파이썬의 조건문인 if, elif, else, case~match 에 대해 알아본다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A1%B0%EA%B1%B4%EB%AC%B8.html#%EC%A1%B0%EA%B1%B4%EB%AC%B8conditional-statements",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A1%B0%EA%B1%B4%EB%AC%B8.html#조건문conditional-statements"
  },"144": {
    "doc": "조건문",
    "title": "if 문The if statement",
    "content": "BNF 표기 및 개념 . if_stmt ::= \"if\" assignment_expression \":\" suite (\"elif\" assignment_expression \":\" suite)* [\"else\" \":\" suite] . | if 절 (필수): if 키워드 뒤에 표현식assignment_expression을 평가하고 결과가 참True인 경우 suite 를 실행한다. | elif 절 (선택): if 절 또는 elif 절 뒤에 여러개의 elif 절이 나올 수 있으며, 조건을 만족하면 슈트를 실행한다. | else 절 (선택): 모든 if 와 elif 조건이 거짓일 경우 실행할 슈트를 지정하는 else 절이다. | . 공통적인 특징으로 모든 평가는 boolean 으로 평가하며 if 문은 조건을 만족하면 뒤에 이어진 elif 또는 else 를 비교하지 않는다. 용어에 대한 보충 자료 . 용어에 대해 그림으로 정리해 보았다. 여기서 suite 는 code block 또는 clause body 라고도 한다. if ~ elif ~ else 사용 예제 . 다음은 사용자로부터 정수를 입력 받아 음수인지 판별하는 프로그램이다. user_number = int(input(\"정수를 입력해주세요: \")) if x &lt; 0: print(\"음수 입니다.\") . &gt;&gt;&gt; 정수를 입력해주세요: -1 음수 입니다. &gt;&gt;&gt; 정수를 입력해주세요: 3 . 프로그램을 확장하여 입력받은 값이 양의 정수일 때 ‘음수가 아닙니다.’ 를 출력하도록 만들어보자. user_number = int(input(\"정수를 입력해주세요: \")) if user_number &lt; 0: print(\"음수 입니다.\") else: print(\"음수가 아닙니다.\") . &gt;&gt;&gt; 정수를 입력해주세요: 3 음수가 아닙니다. 정수는 양의 정수 / 음의 정수 / 0 으로 구분된다. 입력받은 정수 값에 따라 양수인지, 음수인지, 0 인지 판별하는 프로그램 예제이다. user_number = int(input(\"정수를 입력해주세요: \")) if user_number &lt; 0: print(\"음수 입니다.\") elif user_number == 0: print(\"0 입니다.\") else: print(\"양수 입니다.\") . &gt;&gt;&gt; 정수를 입력해주세요: -1 음수 입니다. &gt;&gt;&gt; 정수를 입력해주세요: 0 0 입니다. &gt;&gt;&gt; 정수를 입력해주세요: 100 양수 입니다. if 문은 중첩이 가능하다. 앞서 만든 프로그램에 다음 기능을 추가한다. | 100 보다 큰 경우 ‘매우 큰 양수 입니다.’ 를 출력 | 1 인 경우 ‘1 입니다.’ 를 출력 | . user_number = int(input(\"정수를 입력해주세요: \")) if user_number &lt; 0: print(\"음수 입니다.\") elif user_number == 0: print(\"0 입니다.\") elif user_number == 1: print(\"1 입니다.\") else: if user_number &gt; 1000: print(\"매우 큰 양수 입니다.\") else: print(\"양수 입니다.\") . &gt;&gt;&gt; 정수를 입력해주세요: 1 1 입니다. &gt;&gt;&gt; 정수를 입력해주세요: 2025 매우 큰 양수 입니다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A1%B0%EA%B1%B4%EB%AC%B8.html#if-%EB%AC%B8the-if-statement",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A1%B0%EA%B1%B4%EB%AC%B8.html#if-문the-if-statement"
  },"145": {
    "doc": "조건문",
    "title": "match 문The match Statement",
    "content": "BNF 표기 . match_stmt ::= 'match' subject_expr \":\" NEWLINE INDENT case_block+ DEDENT subject_expr ::= star_named_expression \",\" star_named_expressions? | named_expression case_block ::= 'case' patterns [guard] \":\" block . ### . match 문은 하나의 표현식을 받아 그 값과 case 블록 여러 개에 제시된 연속적인 패턴들과 비교한다. 매칭되는 첫 번째 패턴만 실행되며, 이 과정에서 값의 구성 요소를 변수에 추출할 수 있다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A1%B0%EA%B1%B4%EB%AC%B8.html#match-%EB%AC%B8the-match-statement",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A1%B0%EA%B1%B4%EB%AC%B8.html#match-문the-match-statement"
  },"146": {
    "doc": "조건문",
    "title": "추가 자료",
    "content": "PEP 634 – Structural Pattern Matching: Specification PEP 636 – Structural Pattern Matching: Tutorial . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A1%B0%EA%B1%B4%EB%AC%B8.html#%EC%B6%94%EA%B0%80-%EC%9E%90%EB%A3%8C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A1%B0%EA%B1%B4%EB%AC%B8.html#추가-자료"
  },"147": {
    "doc": "조건문",
    "title": "조건문",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A1%B0%EA%B1%B4%EB%AC%B8.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A0%9C%EC%96%B4_%ED%9D%90%EB%A6%84/%EC%A1%B0%EA%B1%B4%EB%AC%B8.html"
  },"148": {
    "doc": "주석",
    "title": "주석",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A3%BC%EC%84%9D/%EC%A3%BC%EC%84%9D.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A3%BC%EC%84%9D/%EC%A3%BC%EC%84%9D.html"
  },"149": {
    "doc": "주석",
    "title": "개요",
    "content": "코드에 설명이 필요한 경우 주석을 사용한다. 주석은 # 으로 시작하고 코드 실행 시 무시된다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A3%BC%EC%84%9D/%EC%A3%BC%EC%84%9D.html#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A3%BC%EC%84%9D/%EC%A3%BC%EC%84%9D.html#개요"
  },"150": {
    "doc": "주석",
    "title": "PEP8 스타일 가이드 요약",
    "content": ". | 코드와 모순되는 주석은 없는 것보다 나쁘다. 코드가 변경될 때 주석도 업데이트 되어야 한다. | 주석은 완전한 문장이어야 한다. 첫번째 단어는 소문자로 시작하는 식별자가 아닌 한 대문자로 시작되어야 한다. | 블록 주석은 일반적으로 완전한 문장으로 구성된 하나 이상의 문단으로 구성되며, 각 문장은 마침표로 끝난다. | 영어권이 아닌 국가의 Python 코더에게: 당신의 언어를 사용하지 않는 사람들이 절대 읽지 않을 것이라고 120% 확신하지 않는 이상 영어로 주석을 작성하십시오. | . 블록 주석 (Block Comment) . | 주석 뒤에 오는 일부 또는 모든 코드에 적용된다. | 적용되는 코드와 동일한 수준의 들여쓰기에서 작성한다. | *# 과 공백 하나로 시작한다. | . 인라인 주석 (Inline Comment) . | 인라인 주석은 문(Statement)와 같은 줄에 있는 주석이다. | 최소 2 칸 공백으로 코드의 문과 구분되어야 한다. | # 과 공백 하나로 시작한다. | 인라인 주석은 최소한으로 사용한다. | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A3%BC%EC%84%9D/%EC%A3%BC%EC%84%9D.html#pep8-%EC%8A%A4%ED%83%80%EC%9D%BC-%EA%B0%80%EC%9D%B4%EB%93%9C-%EC%9A%94%EC%95%BD",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A3%BC%EC%84%9D/%EC%A3%BC%EC%84%9D.html#pep8-스타일-가이드-요약"
  },"151": {
    "doc": "주석",
    "title": "예제",
    "content": "# 첫 번째 주석입니다. (블록 주석) spam = 1 # 두 번째 주석입니다. (인라인 주석) text = \"# 이 것은 주석이 아닙니다. 따옴표 안에서 작성되었기 때문입니다.\" . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A3%BC%EC%84%9D/%EC%A3%BC%EC%84%9D.html#%EC%98%88%EC%A0%9C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A3%BC%EC%84%9D/%EC%A3%BC%EC%84%9D.html#예제"
  },"152": {
    "doc": "주석",
    "title": "추가 자료",
    "content": ". | PEP8 한국어 번역 | Pycharm TODO | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A3%BC%EC%84%9D/%EC%A3%BC%EC%84%9D.html#%EC%B6%94%EA%B0%80-%EC%9E%90%EB%A3%8C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%A3%BC%EC%84%9D/%EC%A3%BC%EC%84%9D.html#추가-자료"
  },"153": {
    "doc": "초보자를 위한 Django",
    "title": "초보자를 위한 장고",
    "content": "Windows11 과 venv 환경에서 진행합니다. 교육 자료는 Django for Beginners 를 참고하여 작성했습니다. ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC_%EC%9C%84%ED%95%9C_%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django.html#%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%9E%A5%EA%B3%A0",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC_%EC%9C%84%ED%95%9C_%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django.html#초보자를-위한-장고"
  },"154": {
    "doc": "초보자를 위한 Django",
    "title": "초보자를 위한 Django",
    "content": " ",
    "url": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC_%EC%9C%84%ED%95%9C_%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django.html",
    
    "relUrl": "/docs/Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC_%EC%9C%84%ED%95%9C_%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%20%EC%9C%84%ED%95%9C%20Django.html"
  },"155": {
    "doc": "추가 자료",
    "title": "추가 자료",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C.html"
  },"156": {
    "doc": "파이썬 고급 팁",
    "title": "파이썬 고급 팁",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EA%B3%A0%EA%B8%89_%ED%8C%81/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EA%B3%A0%EA%B8%89_%ED%8C%81.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EA%B3%A0%EA%B8%89_%ED%8C%81/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EA%B3%A0%EA%B8%89_%ED%8C%81.html"
  },"157": {
    "doc": "파이썬 내장 자료형",
    "title": "파이썬 내장 자료형",
    "content": "| 자료형 | 분류 | . | int | Numeric Types | . | float | Numeric Types | . | complex | Numeric Types | . | bool | Boolean Type | . | list | Sequence Types | . | tuple | Sequence Types | . | range | Sequence Types | . | str | Text Seqence Type | . | bytes | Binary Sequence Types | . | bytearray | Binary Sequence Types | . | momoryview | Binary Sequence Types | . | set | Set Types | . | frozenset | Set Types | . | dict | Mapping Types | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%82%B4%EC%9E%A5_%EC%9E%90%EB%A3%8C%ED%98%95.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%82%B4%EC%9E%A5_%EC%9E%90%EB%A3%8C%ED%98%95.html"
  },"158": {
    "doc": "파이썬 디자인 패턴",
    "title": "파이썬 디자인 패턴",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4.html"
  },"159": {
    "doc": "파이썬 실전 예제",
    "title": "파이썬 실전 예제",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EC%8B%A4%EC%A0%84_%EC%98%88%EC%A0%9C/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EC%8B%A4%EC%A0%84_%EC%98%88%EC%A0%9C.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EC%8B%A4%EC%A0%84_%EC%98%88%EC%A0%9C/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EC%8B%A4%EC%A0%84_%EC%98%88%EC%A0%9C.html"
  },"160": {
    "doc": "파이썬 튜토리얼",
    "title": "파이썬 튜토리얼",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC.html"
  },"161": {
    "doc": "파이썬 튜토리얼",
    "title": "개요",
    "content": "본 튜토리얼은 파이썬 공식 홈페이지의 The Python Tutorial 을 참고하여 작성했습니다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC.html#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC.html#개요"
  },"162": {
    "doc": "파일시스템 모니터링",
    "title": "파일시스템 모니터링",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EC%8B%A4%EC%A0%84_%EC%98%88%EC%A0%9C/%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C_%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EC%8B%A4%EC%A0%84_%EC%98%88%EC%A0%9C/%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C_%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81.html"
  },"163": {
    "doc": "파일시스템 모니터링",
    "title": "파일 구조",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EC%8B%A4%EC%A0%84_%EC%98%88%EC%A0%9C/%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C_%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81.html#%ED%8C%8C%EC%9D%BC-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EC%8B%A4%EC%A0%84_%EC%98%88%EC%A0%9C/%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C_%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81.html#파일-구조"
  },"164": {
    "doc": "파일시스템 모니터링",
    "title": "settings.py",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EC%8B%A4%EC%A0%84_%EC%98%88%EC%A0%9C/%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C_%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81.html#settingspy",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EC%8B%A4%EC%A0%84_%EC%98%88%EC%A0%9C/%ED%8C%8C%EC%9D%BC%EC%8B%9C%EC%8A%A4%ED%85%9C_%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81.html#settingspy"
  },"165": {
    "doc": "팩토리 패턴",
    "title": "팩토리 패턴The factory pattern",
    "content": "팩토리 디자인 패턴은 클라이언트(즉, 클라이언트 코드)가 객체를 요청할 때, 그 객체가 어디서 생성되는지(어느 클래스에서 생성되는지)를 알 필요가 없다. 팩토리의 핵심 아이디어는 객체 생성 과정을 단순화하는 데 있다. 클라이언트가 직접 클래스를 인스턴스화하는 대신 중앙의 함수를 통해 객체를 생성하면, 생성된 객체들을 추적하기가 더 쉽다. 이처럼 팩토리는 객체를 생성하는 코드와 이를 사용하는 코드를 분리하여 애플리케이션 유지보수의 복잡성을 줄인다. 팩토리는 일반적으로 두 가지 형태로 제공된다. | 팩토리 메서드The factory method 입력 매개변수에 따라 서로 다른 객체를 반환하는 단일 함수(또는 메서드) | 추상 팩토리The abstract factory 관련된 객체 군을 생성하기 위한 여러 팩토리 메서드를 그룹화한 것 | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%8C%A9%ED%86%A0%EB%A6%AC_%ED%8C%A8%ED%84%B4.html#%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4the-factory-pattern",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%8C%A9%ED%86%A0%EB%A6%AC_%ED%8C%A8%ED%84%B4.html#팩토리-패턴the-factory-pattern"
  },"166": {
    "doc": "팩토리 패턴",
    "title": "팩토리 메서드 패턴The factory method pattern",
    "content": "팩토리 메서드는 객체 생성 작업을 하나의 함수로 처리한다. 이 함수를 실행할 때, 우리가 원하는 객체에 대한 정보를 매개변수로 전달하면, 그에 따라 요청된 객체가 생성된다. 흥미로운 점은, 팩토리 메서드를 사용할 경우 결과 객체의 내부 구현이나 생성 경로에 대해 알 필요가 없다는 것이다. 팩터리 매서드 패턴의 사용 사례 . 팩토리 메서드 패턴은 객체 생성 코드가 여러 곳에 흩어져 있어 생성된 객체들을 추적하기 어려울 때 유용하다. 중앙집중식으로 객체를 생성하면 관리가 용이해진다. 실제로 여러 개의 팩토리 메서드를 만들어, 유사한 객체들의 생성을 논리적으로 그룹화하는 경우가 많다. 예를 들어, 한 팩토리 메서드는 MySQL, SQLite 등 서로 다른 데이터베이스에 연결하는 역할을, 또 다른 팩토리 메서드는 원이나 삼각형과 같은 기하학적 객체를 생성하는 역할을 할 수 있다. 또한, 팩토리 메서드는 객체 생성과 사용을 분리할 때 효과적이다. 특정 클래스에 종속되지 않고 함수 호출만으로 객체를 생성하므로, 함수에 변경을 가해도 이를 사용하는 코드에는 영향을 주지 않는다. 추가적으로, 팩토리 메서드는 성능 및 메모리 사용 측면에서도 유리하다. 직접 클래스 인스턴스화를 통해 객체를 생성할 경우 매번 새로운 메모리 할당이 발생하지만, 팩토리 메서드는 필요한 경우에만 객체를 생성함으로써 이를 최적화할 수 있다. 직접 클래스 인스턴스화를 통해 생성된 객체들은 아래 예제와 같이 항상 새로운 메모리 공간에 할당된다. class MyClass: pass if __name__ == '__main__': a = MyClass() b = MyClass() print(id(a) == id(b)) print(id(a)) print(id(b)) . False 2703675540640 2703675548512 . NOTE 출력된 메모리 주소는 실행 환경에 따라 다를 수 있으나, 일반적으로 두 주소는 서로 달라야 한다. 단, Python REPL(대화형 프롬프트)에서는 반복적인 객체 생성을 피하기 위한 내부 최적화로 인해 예외가 발생할 수 있으나, 이는 REPL 에 국한된 현상이다. 팩토리 메서드 패턴 구현 . 데이터는 여러 형태로 제공된다. 데이터를 저장하고 조회하는 파일은 크게 사람이 읽을 수 있는 파일과 바이너리 파일 두 가지로 분류된다. 사람이 읽을 수 있는 파일에는 XML, RSS/Atom, YAML, JSON 등이 있고, 바이너리 파일에는 SQLite 에서 사용하는 .sq3 파일이나 음악 감상에 쓰이는 .mp3 파일 등이 있다. 이 예제에서는 사람이 읽기 쉬운 두 포맷인 XML 과 JSON 에 집중한다. 사람이 읽을 수 있는 파일은 파싱 속도가 바이너리 파일보다 느리지만, 데이터 교환, 검토, 수정이 쉬워 특별한 제약(예: 성능 저하나 독점 바이너리 형식)이 없다면 사용하는 것이 권장된다. 이 경우, XML 파일과 JSON 파일에 저장된 입력 데이터를 파싱하여 정보를 추출하고, 동시에 클라이언트가 외부 서비스(현재 및 미래의 모든 서비스)에 연결하는 부분을 중앙 집중화하고자 한다. 이를 위해 팩토리 메서드 패턴을 사용한다. 예제는 XML 과 JSON 에만 초점을 맞추지만, 다른 서비스 지원을 추가하는 것도 비교적 간단하다. movies.json 파일에는 미국 영화에 관한 정보(제목, 연도, 감독, 출연진, 장르 등)를 담고 있다. movies.json . [ {\"title\":\"After Dark in Central Park\", \"year\":1900, \"director\":null, \"cast\":null, \"genre\":null}, {\"title\":\"Boarding School Girls' Pajama Parade\", \"year\":1900, \"director\":null, \"cast\":null, \"genre\":null}, {\"title\":\"Buffalo Bill's Wild West Parad\", \"year\":1900, \"director\":null, \"cast\":null, \"genre\":null}, {\"title\":\"Caught\", \"year\":1900, \"director\":null, \"cast\":null, \"genre\":null}, {\"title\":\"Clowns Spinning Hats\", \"year\":1900, \"director\":null, \"cast\":null, \"genre\":null}, {\"title\":\"Capture of Boer Battery by British\", \"year\":1900, \"director\":\"James H. White\", \"cast\":null, \"genre\":\"Short documentary\"}, {\"title\":\"The Enchanted Drawing\", \"year\":1900, \"director\":\"J. Stuart Blackton\", \"cast\":null,\"genre\":null}, {\"title\":\"Family Troubles\", \"year\":1900, \"director\":null, \"cast\":null, \"genre\":null}, {\"title\":\"Feeding Sea Lions\", \"year\":1900, \"director\":null, \"cast\":\"Paul Boyton\", \"genre\":null} ] . person.xml 파일은 개인에 대한 정보를 담고 있으며, 전체는 &lt;persons&gt; 태그로 감싸져 있다. 각 사람은 &lt;person&gt; 요소로 표현되며, 예를 들어 다음과 같다. person.xml . &lt;persons&gt; &lt;person&gt; &lt;firstName&gt;John&lt;/firstName&gt; &lt;lastName&gt;Smith&lt;/lastName&gt; &lt;age&gt;25&lt;/age&gt; &lt;address&gt; &lt;streetAddress&gt;21 2nd Street&lt;/streetAddress&gt; &lt;city&gt;New York&lt;/city&gt; &lt;state&gt;NY&lt;/state&gt; &lt;postalCode&gt;10021&lt;/postalCode&gt; &lt;/address&gt; &lt;phoneNumbers&gt; &lt;number type=\"home\"&gt;212 555-1234&lt;/number&gt; &lt;number type=\"fax\"&gt;646 555-4567&lt;/number&gt; &lt;/phoneNumbers&gt; &lt;gender&gt; &lt;type&gt;male&lt;/type&gt; &lt;/gender&gt; &lt;/person&gt; &lt;person&gt; &lt;firstName&gt;Jimy&lt;/firstName&gt; &lt;lastName&gt;Liar&lt;/lastName&gt; &lt;age&gt;19&lt;/age&gt; &lt;address&gt; &lt;streetAddress&gt;18 2nd Street&lt;/streetAddress&gt; &lt;city&gt;New York&lt;/city&gt; &lt;state&gt;NY&lt;/state&gt; &lt;postalCode&gt;10021&lt;/postalCode&gt; &lt;/address&gt; &lt;phoneNumbers&gt; &lt;number type=\"home\"&gt;212 555-1234&lt;/number&gt; &lt;/phoneNumbers&gt; &lt;gender&gt; &lt;type&gt;male&lt;/type&gt; &lt;/gender&gt; &lt;/person&gt; &lt;person&gt; &lt;firstName&gt;Patty&lt;/firstName&gt; &lt;lastName&gt;Liar&lt;/lastName&gt; &lt;age&gt;20&lt;/age&gt; &lt;address&gt; &lt;streetAddress&gt;18 2nd Street&lt;/streetAddress&gt; &lt;city&gt;New York&lt;/city&gt; &lt;state&gt;NY&lt;/state&gt; &lt;postalCode&gt;10021&lt;/postalCode&gt; &lt;/address&gt; &lt;phoneNumbers&gt; &lt;number type=\"home\"&gt;212 555-1234&lt;/number&gt; &lt;number type=\"mobile\"&gt;001 452-8819&lt;/number&gt; &lt;/phoneNumbers&gt; &lt;gender&gt; &lt;type&gt;female&lt;/type&gt; &lt;/gender&gt; &lt;/person&gt; &lt;/persons&gt; . 다음은 팩토리 메서드를 사용하여 JSON 과 XML 추출하는 파이썬 예제이다. import json import xml.etree.ElementTree as ET from pathlib import Path class JSONDataExtractor: def __init__(self, filepath: Path): self.data = {} with open(filepath) as f: self.data = json.load(f) @property def parsed_data(self): return self.data class XMLDataExtractor: def __init__(self, filepath: Path): self.tree = ET.parse(filepath) @property def parsed_data(self): return self.tree def extract_factory(filepath: Path): ext = filepath.name.split(\".\")[-1] if ext == \"json\": return JSONDataExtractor(filepath) elif ext == \"xml\": return XMLDataExtractor(filepath) else: raise ValueError(\"Cannot extract data\") def extract(case: str): dir_path = Path(__file__).parent if case == \"json\": path = dir_path / Path(\"movies.json\") factory = extract_factory(path) data = factory.parsed_data for movie in data: print(f\"- {movie['title']}\") director = movie[\"director\"] if director: print(f\" Director: {director}\") genre = movie[\"genre\"] if genre: print(f\" Genre: {genre}\") elif case == \"xml\": path = dir_path / Path(\"person.xml\") factory = extract_factory(path) data = factory.parsed_data search_xpath = \".//person[lastName='Liar']\" items = data.findall(search_xpath) for item in items: first = item.find(\"firstName\").text last = item.find(\"lastName\").text print(f\"- {first} {last}\") for pn in item.find(\"phoneNumbers\"): pn_type = pn.attrib[\"type\"] pn_val = pn.text phone = f\"{pn_type}: {pn_val}\" print(f\" {phone}\") if __name__ == \"__main__\": print(\"* JSON case *\") extract(case=\"json\") print(\"* XML case *\") extract(case=\"xml\") . 실행 결과는 다음과 같다. * JSON case * - After Dark in Central Park - Boarding School Girls' Pajama Parade - Buffalo Bill's Wild West Parad - Caught - Clowns Spinning Hats - Capture of Boer Battery by British Director: James H. White Genre: Short documentary - The Enchanted Drawing Director: J. Stuart Blackton - Family Troubles - Feeding Sea Lions * XML case * - Jimy Liar home: 212 555-1234 - Patty Liar home: 212 555-1234 mobile: 001 452-8819 . | JSONDataExtractor 클래스 class JSONDataExtractor: def __init__(self, filepath: Path): self.data = {} with open(filepath) as f: self.data = json.load(f) @property def parsed_data(self): return self.data . 파일 경로를 입력받아 JSON 파일을 열고 json.load 로 데이터를 읽는다. parsed_data 프로퍼티를 통해 읽은 데이터를 반환한다. | XMLDataExtractor 클래스 class XMLDataExtractor: def __init__(self, filepath: Path): self.tree = ET.parse(filepath) @property def parsed_data(self): return self.tree . 파일 경로를 입력받아 ElementTree 의 parse 메서드를 사용해 XML 파일을 파싱한다. parsed_data 프로퍼티를 통해 파싱된 XML 트리 객체를 반환한다. | extract_factory 함수 - 팩토리 함수 def extract(case: str): dir_path = Path(__file__).parent if case == \"json\": path = dir_path / Path(\"movies.json\") factory = extract_factory(path) data = factory.parsed_data for movie in data: print(f\"- {movie['title']}\") director = movie[\"director\"] if director: print(f\" Director: {director}\") genre = movie[\"genre\"] if genre: print(f\" Genre: {genre}\") elif case == \"xml\": path = dir_path / Path(\"person.xml\") factory = extract_factory(path) data = factory.parsed_data search_xpath = \".//person[lastName='Liar']\" items = data.findall(search_xpath) for item in items: first = item.find(\"firstName\").text last = item.find(\"lastName\").text print(f\"- {first} {last}\") for pn in item.find(\"phoneNumbers\"): pn_type = pn.attrib[\"type\"] pn_val = pn.text phone = f\"{pn_type}: {pn_val}\" print(f\" {phone}\") . 파일 이름의 확장자를 확인한 후, 확장자가 json 이면 JSONDataExtractor 를, xml 이면 XMLDataExtractor 를 인스턴스화하여 반환한다. 지원하지 않는 확장자인 경우 예외를 발생시킨다. | extract - 메인 함수 def extract(case: str): dir_path = Path(__file__).parent if case == \"json\": path = dir_path / Path(\"movies.json\") factory = extract_factory(path) data = factory.parsed_data for movie in data: print(f\"- {movie['title']}\") director = movie[\"director\"] if director: print(f\" Director: {director}\") genre = movie[\"genre\"] if genre: print(f\" Genre: {genre}\") elif case == \"xml\": path = dir_path / Path(\"person.xml\") factory = extract_factory(path) data = factory.parsed_data search_xpath = \".//person[lastName='Liar']\" items = data.findall(search_xpath) for item in items: first = item.find(\"firstName\").text last = item.find(\"lastName\").text print(f\"- {first} {last}\") for pn in item.find(\"phoneNumbers\"): pn_type = pn.attrib[\"type\"] pn_val = pn.text phone = f\"{pn_type}: {pn_val}\" print(f\" {phone}\") . JSON 케이스: movies.json 파일 경로를 설정하고, 팩토리 함수를 통해 데이터 추출기를 생성한다. 반환된 parsed_data 를 순회하며 영화 제목과, 존재하는 경우 감독과 장르 정보를 출력한다. XML 케이스: person.xml 파일 경로를 설정하고, 팩토리 함수를 통해 데이터 추출기를 생성한다. xpath 를 이용하여 &lt;lastname&gt; 태그가 Liar 인 &lt;person&gt; 요소들을 찾은 후, 각 사람의 이름과 전화번호 정보를 출력한다. | . 팩토리 메서드 패턴을 사용해야 하는가? . 경험 많은 Python 개발자들이 자주 지적하는 주요 비판은, 팩토리 메서드 패턴이 많은 경우 과도하게 설계되었거나 불필요하게 복잡하다는 점이다. Python 의 동적 타이핑과 일급 함수 덕분에, 팩토리 메서드가 해결하고 하는 문제들을 훨씬 간단하고 직관적인 방식으로 처리할 수 있다. 예를 들어, 별도의 팩토리 클래스나 함수를 만들지 않고 단순 함수나 클래스 메서드를 통해 객체를 직접 생성할 수 있다. 또한, Python 은 기본 인자와 키워드 인자 등 다양한 언어 기능을 제공하여, 생성자를 쉽게 확장할 수 있어 별도의 팩토리 메서드가 꼭 필요하지 않을 때가 많다. 따라서 정적 타입 언어인 Java 나 C++ 에서는 팩토리 메서드 패턴이 유용하지만, Python 의 유연하고 동적인 특성에서는 때때로 오히려 불필요하거나 과도하게 복잡하게 느껴질 수 있다. 실제로, 간단한 경우에는 아래와 같이 팩토리 없이 객체를 직접 생성하는 것이 훨씬 Pythonic 하다. if case == \"json\": path = dir_path / Path(\"movies.json\") data = JSONDataExtractor(path).parsed_data . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%8C%A9%ED%86%A0%EB%A6%AC_%ED%8C%A8%ED%84%B4.html#%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4the-factory-method-pattern",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%8C%A9%ED%86%A0%EB%A6%AC_%ED%8C%A8%ED%84%B4.html#팩토리-메서드-패턴the-factory-method-pattern"
  },"167": {
    "doc": "팩토리 패턴",
    "title": "추상 팩토리 패턴 The abstract factory pattern",
    "content": "추상 팩토리 패턴은 팩토리 메서드 아이디어의 일반화된 형태이다. 기본적으로 추상 팩토리는 여러 개의 팩토리 메서드로 구성된 (논리적인) 그룹으로, 각 팩토리 메서드는 서로 다른 종류의 객체를 생성하는 역할을 담당한다. 추상 팩토리 패턴은 팩토리 메서드 패턴의 일반화된 형태이므로, 동일한 이점을 제공한다. 즉, 객체 생성 과정을 추적하기 쉽게 만들고, 객체 생성과 사용을 분리하며 애플리캐이션의 메모리 사용과 성능을 개선할 가능성을 열어준다. 추상 팩토리 패턴 구현 . Bruce Eckel 의 Python 3 Patterns, Recipes and Idioms 책에 포함된 게임 또는 미니게임을 만드는 예제이다. 사용자로부터 입력받은 나이에 따라 어린이용 게임과 성인용 게임 중 하나를 런타임에 선택하여 실행한다. 추상 팩토리는 게임 생성 부분을 담당한다. class Frog: def __init__(self, name): self.name = name def __str__(self): return self.name def interact_with(self, obstacle): act = obstacle.action() msg = f\"{self} the Frog encounters {obstacle} and {act}!\" print(msg) class Bug: def __str__(self): return \"a bug\" def action(self): return \"eats it\" class FrogWorld: def __init__(self, name): print(self) self.player_name = name def __str__(self): return \"\\n\\n\\t------ Frog World -------\" def make_character(self): return Frog(self.player_name) def make_obstacle(self): return Bug() class Wizard: def __init__(self, name): self.name = name def __str__(self): return self.name def interact_with(self, obstacle): act = obstacle.action() msg = f\"{self} the Wizard battles against {obstacle} and {act}!\" print(msg) class Ork: def __str__(self): return \"an evil ork\" def action(self): return \"kills it\" class WizardWorld: def __init__(self, name): print(self) self.player_name = name def __str__(self): return \"\\n\\n\\t------ Wizard World -------\" def make_character(self): return Wizard(self.player_name) def make_obstacle(self): return Ork() # Game environment class GameEnvironment: def __init__(self, factory): self.hero = factory.make_character() self.obstacle = factory.make_obstacle() def play(self): self.hero.interact_with(self.obstacle) def validate_age(name): age = None try: age_input = input(f\"Welcome {name}. How old are you? \") age = int(age_input) except ValueError: print(f\"Age '{age_input}' is invalid, please try again...\") return False, age return True, age def main(): name = input(\"Hello. What's your name? \") valid_input = False while not valid_input: valid_input, age = validate_age(name) game = FrogWorld if age &lt; 18 else WizardWorld environment = GameEnvironment(game(name)) environment.play() if __name__ == \"__main__\": main() . | Frog 클래스 class Frog: def __init__(self, name): self.name = name def __str__(self): return self.name def interact_with(self, obstacle): act = obstacle.action() msg = f\"{self} the Frog encounters {obstacle} and {act}!\" print(msg) . 플레이어가 입력한 이름을 가진 개구리를 생성하며, 장애물과 상호작용할 때 해당 장애물의 행동을 출력한다. | Bug 클래스 class Bug: def __str__(self): return \"a bug\" def action(self): return \"eats it\" . 장애물로 등장하는 벌레를 표현한다. 개구리가 벌레를 만나면 먹어치우는 행동을 한다. | FrogWorld 클래스 - 추상 팩토리 역할 class FrogWorld: def __init__(self, name): print(self) self.player_name = name def __str__(self): return \"\\n\\n\\t------ Frog World -------\" def make_character(self): return Frog(self.player_name) def make_obstacle(self): return Bug() . 플레이어 이름을 받아 개구리 캐릭터와 장애물(벌레)을 생성하는 메서드를 제공한다. 생성 메서드의 이름을 일반화(예: make_charactor, make_obstacle)함으로써, 런타임에 활성 팩토리를 동적으로 변경할 수 있다. | Wizard 클래스 class Wizard: def __init__(self, name): self.name = name def __str__(self): return self.name def interact_with(self, obstacle): act = obstacle.action() msg = f\"{self} the Wizard battles against {obstacle} and {act}!\" print(msg) . Frog 클래스와 유사하게 동작하지만, 장애물과 상호작용할 때는 전투를 벌인다. | Ork 클래스 class Ork: def __str__(self): return \"an evil ork\" def action(self): return \"kills it\" . 장애물로 등장하는 오크를 표현한다. 위자드가 오크를 만나면 공격하여 죽인다. | WizardWorld 클래스 - 추상 팩토리 역할 class WizardWorld: def __init__(self, name): print(self) self.player_name = name def __str__(self): return \"\\n\\n\\t------ Wizard World -------\" def make_character(self): return Wizard(self.player_name) def make_obstacle(self): return Ork() . 플레이어 이름을 받아 위자드 캐릭터와 장애물(오크)을 생성하는 메서드를 제공한다. | GameEnvironment 클래스 class GameEnvironment: def __init__(self, factory): self.hero = factory.make_character() self.obstacle = factory.make_obstacle() def play(self): self.hero.interact_with(self.obstacle) . 추상 팩토리를 인자로 받아 게임의 주인공과 장애물을 생성하고, 주인공과 장애물 간의 상호작용을 실행한다. | validate_age 함수 def validate_age(name): age = None try: age_input = input(f\"Welcome {name}. How old are you? \") age = int(age_input) except ValueError: print(f\"Age '{age_input}' is invalid, please try again...\") return False, age return True, age . 사용자로부터 나이를 입력바다 유효한지 검증한다. 유효하지 않으면 False 와 함께 None 을, 유효하면 True 와 함께 입력받은 나이를 반환한다. | main 함수 def main(): name = input(\"Hello. What's your name? \") valid_input = False while not valid_input: valid_input, age = validate_age(name) game = FrogWorld if age &lt; 18 else WizardWorld environment = GameEnvironment(game(name)) environment.play() . 사용자로부터 이름과 나이를 입력받은 후, 나이에 따라 어린이용 게임 FrogWorld 또는 성인용 게임인 WizardWorld 를 선택하여 게임을 시작한다. | . 어린이(10 세) 인 경우의 결과이다. Hello. What's your name? nova Welcome nova. How old are you? 9 ------ Frog World ------- nova the Frog encounters a bug and eats it! . 성인(36 세) 인 경우 다음과 같은 결과가 나온다. Hello. What's your name? Arthur Welcome Arthur. How old are you? 36 ------ Wizard World ------- Arthur the Wizard battles against an evil ork and kills it! . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%8C%A9%ED%86%A0%EB%A6%AC_%ED%8C%A8%ED%84%B4.html#%EC%B6%94%EC%83%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4-the-abstract-factory-pattern",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%8C%A9%ED%86%A0%EB%A6%AC_%ED%8C%A8%ED%84%B4.html#추상-팩토리-패턴-the-abstract-factory-pattern"
  },"168": {
    "doc": "팩토리 패턴",
    "title": "추가 자료",
    "content": ". | Django 의 forms 모듈 - 팩토리 메소드 예제 | factory_boy 패키지 - 추상 팩토리 예제 | model_bakery 패키지 - 추상 팩토리 예제 | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%8C%A9%ED%86%A0%EB%A6%AC_%ED%8C%A8%ED%84%B4.html#%EC%B6%94%EA%B0%80-%EC%9E%90%EB%A3%8C",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%8C%A9%ED%86%A0%EB%A6%AC_%ED%8C%A8%ED%84%B4.html#추가-자료"
  },"169": {
    "doc": "팩토리 패턴",
    "title": "팩토리 패턴",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%8C%A9%ED%86%A0%EB%A6%AC_%ED%8C%A8%ED%84%B4.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%8C%A9%ED%86%A0%EB%A6%AC_%ED%8C%A8%ED%84%B4.html"
  },"170": {
    "doc": "프로토 타입 패턴",
    "title": "프로토 타입 패턴The prototype pattern",
    "content": "프로토타입 패턴은 새 객체를 처음부터 생성하는 대신 기존 객체를 복사하여 새로운 객체를 만들어내는 방법이다. 이 패턴은 객체를 초기화하는 비용이 새 객체를 생성하는 비용보다 더 크거나 복잡할 때 특히 유용하다. 본질적으로 프로토타입 패턴은 기존 인스턴스를 복제하여 클래스의 새로운 인스턴스를 생성함으로써, 새 객체 초기화에 따른 오버헤드를 피할 수 있도록 한다. 가장 단순화 형태에서는 이 패턴은 입력 매개변수로 객체를 받아 그 객체의 복제본을 반환하는 clone() 함수와 같다. 파이썬에서는 copy.deepcopy() 함수를 사용하여 이 작업을 수행할 수 있다. 프로토타입 패턴은 기존 객체를 변경하지 않고 그대로 유지해야 할 때, 해당 객체의 정확한 복사본을 만들어 일부만 변경하고자 할 때 유용하다. 또한 데이터베이스에서 불러온 객체와 그 객체가 참조하고 있는 다른 데이터베이스 기반 객체들을 복제해야 하는 경우가 종종 발생하는데, 이러한 복잡한 객체를 여러 번 초기화하기 위해 데이터베이스에 여러 번 쿼리를 날리는 비용을 줄이기 위한 편리한 방법이다. ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%ED%8C%A8%ED%84%B4.html#%ED%94%84%EB%A1%9C%ED%86%A0-%ED%83%80%EC%9E%85-%ED%8C%A8%ED%84%B4the-prototype-pattern",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%ED%8C%A8%ED%84%B4.html#프로토-타입-패턴the-prototype-pattern"
  },"171": {
    "doc": "프로토 타입 패턴",
    "title": "프로토 타입 패턴",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%ED%8C%A8%ED%84%B4.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%EC%83%9D%EC%84%B1_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%ED%8C%A8%ED%84%B4.html"
  },"172": {
    "doc": "한국어 - 영어",
    "title": "한국어 - 영어",
    "content": "| 한국어 | 영어 | . | 결합 | Concatenation | . | 개행 | New line | . | 객체 | Object | . | 논리 연산자 | Boolean operators | . | 변수 | Variable | . | 복합 연산자 | Augmented assignment | . | 비교 연산자 | Comparison operators | . | 원시 문자열 | Raw String | . | 산술 연산자 | Arithmetic operators | . | 자료형 | Data type | . | 형 변환 | Type conversion | . | 복합 자료형 | Compound data types | . ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%ED%95%9C%EA%B5%AD%EC%96%B4-%EC%98%81%EC%96%B4.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/%EC%B6%94%EA%B0%80_%EC%9E%90%EB%A3%8C/%ED%95%9C%EA%B5%AD%EC%96%B4-%EC%98%81%EC%96%B4.html"
  },"173": {
    "doc": "행동 디자인 패턴",
    "title": "행동 디자인 패턴",
    "content": " ",
    "url": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%ED%96%89%EB%8F%99_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%96%89%EB%8F%99_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4.html",
    
    "relUrl": "/docs/%ED%8C%8C%EC%9D%B4%EC%8D%AC_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/Gang_of_Four/%ED%96%89%EB%8F%99_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4/%ED%96%89%EB%8F%99_%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4.html"
  }
}
